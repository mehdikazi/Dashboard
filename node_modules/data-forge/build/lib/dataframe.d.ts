import { IIndex } from './index';
import { ISeries, SelectorWithIndexFn, PredicateFn, ComparerFn, SelectorFn, AggregateFn, Zip2Fn, Zip3Fn, ZipNFn, CallbackFn, JoinFn, GapFillFn } from './series';
/**
 * An object whose fields specify named columns.
 */
export interface IColumnSpec {
    [index: string]: Iterable<any> | ISeries<any, any>;
}
/**
 * Specifes the format per column when converting columns to strings.
 */
export interface IFormatSpec {
    [index: string]: string;
}
/**
 * Specification that defines output columns for a pivot.
 */
export interface IAggregatorSpec {
    [index: string]: (values: ISeries<number, any>) => any;
}
/**
 * Specification for pivoting values in named columns..
 */
export interface IPivotAggregateSpec {
    [index: string]: IAggregatorSpec;
}
/**
 * Defines the configuration for a new column.
 */
export interface IColumnConfig {
    /**
     * The name of the new column.
     */
    name: string;
    /**
     * The series of values for the column.
     */
    series: Iterable<any> | ISeries<any, any>;
}
/**
 * DataFrame configuration.
 */
export interface IDataFrameConfig<IndexT, ValueT> {
    values?: Iterable<ValueT>;
    rows?: Iterable<any[]>;
    index?: Iterable<IndexT>;
    pairs?: Iterable<[IndexT, ValueT]>;
    columnNames?: Iterable<string>;
    baked?: boolean;
    considerAllRows?: boolean;
    columns?: Iterable<IColumnConfig> | IColumnSpec;
}
/**
 * Represents a name column in a dataframe.
 */
export interface IColumn {
    /**
     * The name of the column.
     */
    name: string;
    /**
     * The data type of the column.
     */
    type: string;
    /**
     * The data series from the column.
     */
    series: ISeries<any, any>;
}
/**
 * An object whose fields specify named columns or functions to generate columns.
 */
export interface IColumnGenSpec {
    [index: string]: ISeries<any, any> | SeriesSelectorFn<any, any, any>;
}
/**
 * Specifies how to rename columns.
 */
export interface IColumnRenameSpec {
    [index: string]: string;
}
/**
 * Specifies columns to transform.
 */
export interface IColumnTransformSpec {
    [index: string]: SelectorWithIndexFn<any, any>;
}
/**
 * A spec for aggregating a collection of names columns.
 */
export interface IColumnAggregateSpec {
    [index: string]: AggregateFn<any, any>;
}
/**
 * A selector function that can select a series from a dataframe.
 */
export declare type SeriesSelectorFn<IndexT, DataFrameValueT, SeriesValueT> = (dataFrame: IDataFrame<IndexT, DataFrameValueT>) => ISeries<IndexT, SeriesValueT>;
export declare type DataFrameConfigFn<IndexT, ValueT> = () => IDataFrameConfig<IndexT, ValueT>;
/**
 * Represents the frequency of a type in a series or dataframe.
 */
export interface ITypeFrequency {
    /**
     * Name of the column containing the value.
     */
    Column: string;
    /**
     * The name of the type.
     */
    Type: string;
    /**
     * The frequency of the type's appearance in the series or dataframe.
     */
    Frequency: number;
}
/**
 * Represents the frequency of a value in a series or dataframe.
 */
export interface IValueFrequency {
    /**
     * Name of the column containing the value.
     */
    Column: string;
    /**
     * The value.
     */
    Value: any;
    /**
     * The frequency of the value's appearance in the series or dataframe.
     */
    Frequency: number;
}
/**
 * Interface that represents a dataframe.
 * A dataframe contains an indexed sequence of data records.
 * Think of it as a spreadsheet or CSV file in memory.
 *
 * Each data record contains multiple named fields, the value of each field represents one row in a column of data.
 * Each column of data is a named {@link Series}.
 * You think of a dataframe a collection of named data series.
 *
 * @typeparam IndexT The type to use for the index.
 * @typeparam ValueT The type to use for each row/data record.
 */
export interface IDataFrame<IndexT = number, ValueT = any> extends Iterable<ValueT> {
    /**
     * Get an iterator to enumerate the values of the dataframe.
     */
    [Symbol.iterator](): Iterator<ValueT>;
    /**
     * Get the names of the columns in the dataframe.
     *
     * @returns Returns an array of the column names in the dataframe.
     */
    getColumnNames(): string[];
    /**
     * Retreive a collection of all columns in the dataframe.
     *
     * @returns Returns a series the columns in the dataframe.
     */
    getColumns(): ISeries<number, IColumn>;
    /**
     * Cast the value of the dataframe to a new type.
     * This operation has no effect but to retype the value that the dataframe contains.
     */
    cast<NewValueT>(): IDataFrame<IndexT, NewValueT>;
    /**
     * Get the index for the dataframe.
     */
    getIndex(): IIndex<IndexT>;
    /**
     * Set a named column as the index of the data-frame.
     *
     * @param columnName - Name or index of the column to set as the index.
     *
     * @returns Returns a new dataframe with the values of a particular named column as the index.
     */
    setIndex<NewIndexT = any>(columnName: string): IDataFrame<NewIndexT, ValueT>;
    /**
     * Apply a new index to the dataframe.
     *
     * @param newIndex The new index to apply to the dataframe.
     *
     * @returns Returns a new dataframe with the specified index attached.
     */
    withIndex<NewIndexT>(newIndex: Iterable<NewIndexT> | SelectorFn<ValueT, NewIndexT>): IDataFrame<NewIndexT, ValueT>;
    /**
     * Resets the index of the dataframe back to the default zero-based sequential integer index.
     *
     * @returns Returns a new dataframe with the index reset to the default zero-based index.
     */
    resetIndex(): IDataFrame<number, ValueT>;
    /**
     * Retreive a series from a column of the dataframe.
     *
     * @param columnName Specifies the name of the column that contains the series to retreive.
     */
    getSeries<SeriesValueT = any>(columnName: string): ISeries<IndexT, SeriesValueT>;
    /**
     * Returns true if the column with the requested name exists in the dataframe.
     *
     * @param columnName - Name of the column to check.
     */
    hasSeries(columnName: string): boolean;
    /**
     *
     * Verify the existance of a column and return it.
     * Throws an exception if the column doesn't exist.
     *
     * @param columnName - Name or index of the column to retreive.
     */
    expectSeries<SeriesValueT>(columnName: string): ISeries<IndexT, SeriesValueT>;
    /**
     * Create a new dataframe with an additional column specified by the passed-in series.
     *
     * @param columnNameOrSpec - The name of the column to add or replace.
     * @param [series] - When columnNameOrSpec is a string that identifies the column to add, this specifies the Series to add to the data-frame or a function that produces a series (given a dataframe).
     *
     * @returns Returns a new dataframe replacing or adding a particular named column.
     */
    withSeries<SeriesValueT>(columnNameOrSpec: string | IColumnGenSpec, series?: ISeries<IndexT, SeriesValueT> | SeriesSelectorFn<IndexT, ValueT, SeriesValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Add a series if it doesn't already exist.
     *
     * @param columnNameOrSpec - The name of the series to add or a column spec that defines the new column.
     * @param series - The series to add to the dataframe. Can also be a function that returns the series.
     *
     * @returns Returns a new dataframe with the specified series added, if the series didn't already exist. Otherwise if the requested series already exists the same dataframe is returned.
     */
    ensureSeries<SeriesValueT>(columnNameOrSpec: string | IColumnGenSpec, series?: ISeries<IndexT, SeriesValueT> | SeriesSelectorFn<IndexT, ValueT, SeriesValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Create a new data-frame from a subset of columns.
     *
     * @param columnNames - Array of column names to include in the new data-frame.
     *
     * @returns Returns a dataframe with a subset of columns from the input dataframe.
     */
    subset<NewValueT = ValueT>(columnNames: string[]): IDataFrame<IndexT, NewValueT>;
    /**
     * Create a new data frame with the requested column or columns dropped.
     *
     * @param columnOrColumns - Specifies the column name (a string) or columns (array of column names) to drop.
     *
     * @returns Returns a new dataframe with a particular name column or columns removed.
     */
    dropSeries<NewValueT = ValueT>(columnOrColumns: string | string[]): IDataFrame<IndexT, NewValueT>;
    /**
     * Create a new data frame with columns reordered.
     * New column names create new columns (with undefined values), omitting existing column names causes those columns to be dropped.
     *
     * @param columnNames - The new order for columns.
     *
     * @returns Returns a new dataframe with columns remapped according to the specified column layout.
     */
    reorderSeries<NewValueT = ValueT>(columnNames: string[]): IDataFrame<IndexT, NewValueT>;
    /**
     * Bring the name column (or columns) to the front, making it (or them) the first column(s) in the data-frame.
     *
     * @param columnOrColumns - Specifies the column or columns to bring to the front.
     *
     * @returns Returns a new dataframe with 1 or more columns bought to the front of the column ordering.
     */
    bringToFront(columnOrColumns: string | string[]): IDataFrame<IndexT, ValueT>;
    /**
     * Bring the name column (or columns) to the back, making it (or them) the last column(s) in the data-frame.
     *
     * @param columnOrColumns - Specifies the column or columns to bring to the back.
     *
     * @returns Returns a new dataframe with 1 or more columns bought to the back of the column ordering.
     */
    bringToBack(columnOrColumns: string | string[]): IDataFrame<IndexT, ValueT>;
    /**
     * Create a new data-frame with renamed series.
     *
     * @param newColumnNames - A column rename spec - maps existing column names to new column names.
     *
     * @returns Returns a new dataframe with columns renamed.
     */
    renameSeries<NewValueT = ValueT>(newColumnNames: IColumnRenameSpec): IDataFrame<IndexT, NewValueT>;
    /**
    * Extract values from the dataframe as an array.
    * This forces lazy evaluation to complete.
    *
    * @returns Returns an array of values contained within the dataframe.
    */
    toArray(): ValueT[];
    /**
     * Retreive the index and values from the DataFrame as an array of pairs.
     * Each pairs is [index, value].
     *
     * @returns Returns an array of pairs that contains the dataframe content. Each pair is a two element array that contains an index and a value.
     */
    toPairs(): ([IndexT, ValueT])[];
    /**
     * Convert the dataframe to a JavaScript object.
     *
     * @param {function} keySelector - Function that selects keys for the resulting object.
     * @param {valueSelector} keySelector - Function that selects values for the resulting object.
     *
     * @returns {object} Returns a JavaScript object generated from the input sequence by the key and value selector funtions.
     */
    toObject<KeyT = any, FieldT = any, OutT = any>(keySelector: (value: ValueT) => KeyT, valueSelector: (value: ValueT) => FieldT): OutT;
    /**
     * Bake the data frame to an array of rows.
     *
     *  @returns Returns an array of rows. Each row is an array of values in column order.
     */
    toRows(): any[][];
    /**
     * Generate a new dataframe based by calling the selector function on each value.
     *
     * @param selector Selector function that transforms each value to create a new dataframe.
     *
     * @returns Returns a new dataframe that has been transformed by the selector function.
     */
    select<ToT>(selector: SelectorWithIndexFn<ValueT, ToT>): IDataFrame<IndexT, ToT>;
    /**
     * Generate a new dataframe based on the results of the selector function.
     *
     * @param selector Selector function that transforms each value into a list of values.
     *
     * @returns  Returns a new dataframe with values that have been produced by the selector function.
     */
    selectMany<ToT>(selector: SelectorWithIndexFn<ValueT, Iterable<ToT>>): IDataFrame<IndexT, ToT>;
    /**
     * Transform one or more columns. This is equivalent to extracting a column, calling 'select' on it,
     * then plugging it back in as the same column.
     *
     * @param columnSelectors - Object with field names for each column to be transformed. Each field you be a selector that transforms that column.
     *
     * @returns Returns a new dataframe with 1 or more columns transformed.
     */
    transformSeries<NewValueT = ValueT>(columnSelectors: IColumnTransformSpec): IDataFrame<IndexT, NewValueT>;
    /**
     * Generate new columns based on existing rows.
     *
     * @param generator - Generator function that transforms each row to a new set of columns.
     *
     * @returns Returns a new dataframe with 1 or more new columns.
     */
    generateSeries<NewValueT = ValueT>(generator: SelectorWithIndexFn<any, any> | IColumnTransformSpec): IDataFrame<IndexT, NewValueT>;
    /**
     * Deflate a data-frame to a series.
     *
     * @param [selector] - Optional selector function that transforms each row to a new sequence of values.
     *
     * @returns Returns a series that was created from the input dataframe.
     */
    deflate<ToT = ValueT>(selector?: SelectorWithIndexFn<ValueT, ToT>): ISeries<IndexT, ToT>;
    /**
     * Inflate a named series in the data-frame to 1 or more new series in the new dataframe.
     *
     * @param columnName - Name or index of the column to retreive.
     * @param [selector] - Optional selector function that transforms each value in the column to new columns. If not specified it is expected that each value in the column is an object whose fields define the new column names.
     *
     * @returns Returns a new dataframe with a column inflated to 1 or more new columns.
     */
    inflateSeries<NewValueT = ValueT>(columnName: string, selector?: SelectorWithIndexFn<IndexT, any>): IDataFrame<IndexT, ValueT>;
    /**
     * Segment a dataframe into 'windows'. Returns a new series. Each value in the new dataframe contains a 'window' (or segment) of the original dataframe.
     * Use select or selectPairs to aggregate.
     *
     * @param period - The number of values in the window.
     *
     * @returns Returns a new series, each value of which is a 'window' (or segment) of the original dataframe.
     */
    window(period: number): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Segment a dataframe into 'rolling windows'. Returns a new series. Each value in the new series contains a 'window' (or segment) of the original dataframe.
    *
     * @param period - The number of values in the window.
     *
     * @returns Returns a new series, each value of which is a 'window' (or segment) of the original dataframe.
     */
    rollingWindow(period: number): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Groups sequential values into variable length 'windows'.
     *
     * @param comparer - Predicate that compares two values and returns true if they should be in the same window.
     *
     * @returns Returns a series of groups. Each group is itself a dataframe that contains the values in the 'window'.
     */
    variableWindow(comparer: ComparerFn<ValueT, ValueT>): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Collapase distinct values that happen to be sequential.
     *
     * @param [selector] - Optional selector function to determine the value used to compare for duplicates.
     *
     * @returns Returns a new dataframe with duplicate values that are sequential removed.
     */
    sequentialDistinct<ToT = ValueT>(selector?: SelectorFn<ValueT, ToT>): IDataFrame<IndexT, ValueT>;
    /**
     * Aggregate the values in the dataframe.
     *
     * @param [seed] - Optional seed value for producing the aggregation.
     * @param selector - Function that takes the seed and then each value in the dataframe and produces the aggregate value.
     *
     * @returns Returns a new value that has been aggregated from the input sequence by the 'selector' function.
     */
    aggregate<ToT = ValueT>(seedOrSelector: AggregateFn<ValueT, ToT> | ToT | IColumnAggregateSpec, selector?: AggregateFn<ValueT, ToT>): ToT;
    /**
     * Skip a number of values in the dataframe.
     *
     * @param numValues - Number of values to skip.     *
     * @returns Returns a new dataframe or dataframe with the specified number of values skipped.
     */
    skip(numValues: number): IDataFrame<IndexT, ValueT>;
    /**
     * Skips values in the series while a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series with all initial sequential values removed that match the predicate.
     */
    skipWhile(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Skips values in the series until a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series with all initial sequential values removed that don't match the predicate.
     */
    skipUntil(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Take a number of rows in the series.
     *
     * @param numRows - Number of rows to take.
     *
     * @returns Returns a new series with up to the specified number of values included.
     */
    take(numRows: number): IDataFrame<IndexT, ValueT>;
    /**
     * Take values from the series while a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series that only includes the initial sequential values that have matched the predicate.
     */
    takeWhile(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Take values from the series until a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series or dataframe that only includes the initial sequential values that have not matched the predicate.
     */
    takeUntil(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Count the number of values in the series.
     *
     * @returns Returns the count of all values in the series.
     */
    count(): number;
    /**
     * Get the first value of the series.
     *
     * @returns Returns the first value of the series.
     */
    first(): ValueT;
    /**
     * Get the last value of the series.
     *
     * @returns Returns the last value of the series.
     */
    last(): ValueT;
    /**
     * Get the value at a specified index.
     *
     * @param index - Index to for which to retreive the value.
     *
     * @returns Returns the value from the specified index in the sequence or undefined if there is no such index in the series.
     */
    at(index: IndexT): ValueT | undefined;
    /**
     * Get X values from the start of the series.
     *
     * @param numValues - Number of values to take.
     *
     * @returns Returns a new series that has only the specified number of values taken from the start of the input sequence.
     */
    head(numValues: number): IDataFrame<IndexT, ValueT>;
    /**
     * Get X values from the end of the series.
     *
     * @param numValues - Number of values to take.
     *
     * @returns Returns a new series that has only the specified number of values taken from the end of the input sequence.
     */
    tail(numValues: number): IDataFrame<IndexT, ValueT>;
    /**
     * Filter a series by a predicate selector.
     *
     * @param predicate - Predicte function to filter rows of the series.
     *
     * @returns Returns a new series containing only the values that match the predicate.
     */
    where(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Invoke a callback function for each value in the series.
     *
     * @param callback - The calback to invoke for each value.
     *
     * @returns Returns the input series with no modifications.
     */
    forEach(callback: CallbackFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Determine if the predicate returns truthy for all values in the series.
     * Returns false as soon as the predicate evaluates to falsy.
     * Returns true if the predicate returns truthy for all values in the series.
     * Returns false if the series is empty.
     *
     * @param predicate - Predicate function that receives each value in turn and returns truthy for a match, otherwise falsy.
     *
     * @returns {boolean} Returns true if the predicate has returned truthy for every value in the sequence, otherwise returns false.
     */
    all(predicate: PredicateFn<ValueT>): boolean;
    /**
     * Determine if the predicate returns truthy for any of the values in the series.
     * Returns true as soon as the predicate returns truthy.
     * Returns false if the predicate never returns truthy.
     * If no predicate is specified the value itself is checked.
     *
     * @param [predicate] - Optional predicate function that receives each value in turn and returns truthy for a match, otherwise falsy.
     *
     * @returns Returns true if the predicate has returned truthy for any value in the sequence, otherwise returns false.
     */
    any(predicate?: PredicateFn<ValueT>): boolean;
    /**
     * Determine if the predicate returns truthy for none of the values in the series.
     * Returns true for an empty series.
     * Returns true if the predicate always returns falsy.
     * Otherwise returns false.
     * If no predicate is specified the value itself is checked.
     *
     * @param [predicate] - Optional predicate function that receives each value in turn and returns truthy for a match, otherwise falsy.
     *
     * @returns Returns true if the predicate has returned truthy for no values in the series, otherwise returns false.
     */
    none(predicate?: PredicateFn<ValueT>): boolean;
    /**
     * Get a new series containing all values starting at and after the specified index value.
     *
     * @param indexValue - The index value to search for before starting the new series.
     *
     * @returns Returns a new series containing all values starting at and after the specified index value.
     */
    startAt(indexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Get a new series containing all values up until and including the specified index value (inclusive).
     *
     * @param indexValue - The index value to search for before ending the new series.
     *
     * @returns Returns a new series containing all values up until and including the specified index value.
     */
    endAt(indexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Get a new series containing all values up to the specified index value (exclusive).
     *
     * @param indexValue - The index value to search for before ending the new series.
     *
     * @returns Returns a new series containing all values up to the specified inde value.
     */
    before(indexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Get a new series containing all values after the specified index value (exclusive).
     *
     * @param indexValue - The index value to search for.
     *
     * @returns Returns a new series containing all values after the specified index value.
     */
    after(indexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Get a new dataframe containing all values between the specified index values (inclusive).
     *
     * @param startIndexValue - The index where the new sequence starts.
     * @param endIndexValue - The index where the new sequence ends.
     *
     * @returns Returns a new dataframe containing all values between the specified index values (inclusive).
     */
    between(startIndexValue: IndexT, endIndexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Format the dataframe for display as a string.
     * This forces lazy evaluation to complete.
     *
     * @returns Generates and returns a string representation of the dataframe or dataframe.
     */
    toString(): string;
    /**
     * Parse a column with string values to a column with int values.
     *
     * @param columnNameOrNames - Specifies the column name or array of column names to parse.
     *
     * @returns Returns a new dataframe with a particular named column parsed as ints.
     */
    parseInts(columnNameOrNames: string | string[]): IDataFrame<IndexT, ValueT>;
    /**
     * Parse a column with string values to a column with float values.
     *
     * @param columnNameOrNames - Specifies the column name or array of column names to parse.
     *
     * @returns  Returns a new dataframe with a particular named column parsed as floats.
     */
    parseFloats(columnNameOrNames: string | string[]): IDataFrame<IndexT, ValueT>;
    /**
     * Parse a column with string values to a column with date values.
     *
     * @param columnNameOrNames - Specifies the column name or array of column names to parse.
     * @param [formatString] - Optional formatting string for dates.
     *
     * @returns Returns a new dataframe with a particular named column parsed as dates.
     */
    parseDates(columnNameOrNames: string | string[], formatString?: string): IDataFrame<IndexT, ValueT>;
    /**
     * Convert a column of values of different types to a column of string values.
     *
     * @param columnNames - Specifies the column name or array of column names to convert to strings. Can also be a format spec that specifies which columns to convert and what their format should be.
     * @param [formatString] - Optional formatting string for dates.
     *
     * Numeral.js is used for number formatting.
     * http://numeraljs.com/
     *
     * Moment is used for date formatting.
     * https://momentjs.com/docs/#/parsing/string-format/

     * @returns Returns a new dataframe with a particular named column convert to strings.
     */
    toStrings(columnNames: string | string[] | IFormatSpec, formatString?: string): IDataFrame<IndexT, ValueT>;
    /**
     * Produces a new data frame with all string values truncated to the requested maximum length.
     *
     * @param maxLength - The maximum length of the string values after truncation.
     *
     * @returns Returns a new dataframe with all strings truncated to the specified maximum length.
     */
    truncateStrings(maxLength: number): IDataFrame<IndexT, ValueT>;
    /**
     * Forces lazy evaluation to complete and 'bakes' the dataframe into memory.
     *
     * @returns Returns a dataframe that has been 'baked', all lazy evaluation has completed.
     */
    bake(): IDataFrame<IndexT, ValueT>;
    /**
     * Reverse the dataframe.
     *
     * @returns Returns a new dataframe that is the reverse of the input.
     */
    reverse(): IDataFrame<IndexT, ValueT>;
    /**
     * Returns only values in the dataframe that have distinct values.
     *
     * @param selector - Selects the value used to compare for duplicates.
     *
     * @returns Returns a dataframe containing only unique values as determined by the 'selector' function.
     */
    distinct<ToT>(selector?: SelectorFn<ValueT, ToT>): IDataFrame<IndexT, ValueT>;
    /**
     * Group the dataframe according to the selector.
     *
     * @param selector - Selector that defines the value to group by.
     *
     * @returns Returns a series of groups. Each group is a dataframe with values that have been grouped by the 'selector' function.
     */
    groupBy<GroupT>(selector: SelectorWithIndexFn<ValueT, GroupT>): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Group sequential values into a series of windows.
     *
     * @param selector - Optional selector that defines the value to group by.
     *
     * @returns Returns a series of groups. Each group is a series with values that have been grouped by the 'selector' function.
     */
    groupSequentialBy<GroupT>(selector?: SelectorFn<ValueT, GroupT>): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Concatenate multiple other dataframes onto this dataframe.
     *
     * @param dataframes - Multiple arguments. Each can be either a dataframe or an array of dataframes.
     *
     * @returns Returns a single dataframe concatenated from multiple input dataframes.
     */
    concat(...dataframes: (IDataFrame<IndexT, ValueT>[] | IDataFrame<IndexT, ValueT>)[]): IDataFrame<IndexT, ValueT>;
    /**
    * Zip together multiple dataframes to create a new dataframe.
    * Preserves the index of the first dataframe.
    *
    * @param s2, s3, s4, s4 - Multiple dataframes to zip.
    * @param zipper - Zipper function that produces a new dataframe based on the input dataframes.
    *
    * @returns Returns a single dataframe concatenated from multiple input dataframes.
    */
    zip<Index2T, Value2T, ResultT>(s2: IDataFrame<Index2T, Value2T>, zipper: Zip2Fn<ValueT, Value2T, ResultT>): IDataFrame<IndexT, ResultT>;
    zip<Index2T, Value2T, Index3T, Value3T, ResultT>(s2: IDataFrame<Index2T, Value2T>, s3: IDataFrame<Index3T, Value3T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT>): IDataFrame<IndexT, ResultT>;
    zip<Index2T, Value2T, Index3T, Value3T, Index4T, Value4T, ResultT>(s2: IDataFrame<Index2T, Value2T>, s3: IDataFrame<Index3T, Value3T>, s4: IDataFrame<Index4T, Value4T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT>): IDataFrame<IndexT, ResultT>;
    zip<ResultT>(...args: any[]): IDataFrame<IndexT, ResultT>;
    /**
     * Sorts the dataframe by a value defined by the selector (ascending).
     *
     * @param selector Selects the value to sort by.
     *
     * @returns Returns a new ordered dataframe that has been sorted by the value returned by the selector.
     */
    orderBy<SortT>(selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;
    /**
     * Sorts the dataframe by a value defined by the selector (descending).
     *
     * @param selector Selects the value to sort by.
     *
     * @returns Returns a new ordered dataframe that has been sorted by the value returned by the selector.
     */
    orderByDescending<SortT>(selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;
    /**
     * Returns the unique union of values between two dataframes.
     *
     * @param other - The other dataframe to combine.
     * @param [selector] - Optional function that selects the value to compare to detemrine distinctness.
     *
     * @returns Returns the union of two dataframes.
     */
    union<KeyT = ValueT>(other: IDataFrame<IndexT, ValueT>, selector?: SelectorFn<ValueT, KeyT>): IDataFrame<IndexT, ValueT>;
    /**
     * Returns the intersection of values between two dataframes.
     *
     * @param inner - The other dataframes to combine.
     * @param [outerSelector] - Optional function to select the key for matching the two dataframes.
     * @param [innerSelector] - Optional function to select the key for matching the two dataframes.
     *
     * @returns Returns the intersection of two dataframes.
     */
    intersection<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerSelector?: SelectorFn<ValueT, KeyT>, innerSelector?: SelectorFn<InnerValueT, KeyT>): IDataFrame<IndexT, ValueT>;
    /**
     * Returns the exception of values between two dataframes.
     *
     * @param inner - The other dataframe to combine.
     * @param [outerSelector] - Optional function to select the key for matching the two dataframes.
     * @param [innerSelector] - Optional function to select the key for matching the two dataframes.
     *
     * @returns Returns the difference between the two dataframes.
     */
    except<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerSelector?: SelectorFn<ValueT, KeyT>, innerSelector?: SelectorFn<InnerValueT, KeyT>): IDataFrame<IndexT, ValueT>;
    /**
      * Correlates the elements of two dataframes on matching keys.
      *
      * @param this - The outer dataframe to join.
      * @param inner - The inner dataframe to join.
      * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
      * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
      * @param resultSelector - Selector that defines how to merge outer and inner values.
      *
      * @returns Returns the joined dataframe.
      */
    join<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerKeySelector: SelectorFn<ValueT, KeyT>, innerKeySelector: SelectorFn<InnerValueT, KeyT>, resultSelector: JoinFn<ValueT, InnerValueT, ResultValueT>): IDataFrame<number, ResultValueT>;
    /**
     * Performs an outer join on two dataframes. Correlates the elements based on matching keys.
     * Includes elements from both dataframes that have no correlation in the other dataframe.
     *
     * @param this - The outer dataframe to join.
     * @param inner - The inner dataframe to join.
     * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
     * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
     * @param resultSelector - Selector that defines how to merge outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @returns Returns the joined dataframe.
     */
    joinOuter<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerKeySelector: SelectorFn<ValueT, KeyT>, innerKeySelector: SelectorFn<InnerValueT, KeyT>, resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>): IDataFrame<number, ResultValueT>;
    /**
     * Performs a left outer join on two dataframe. Correlates the elements based on matching keys.
     * Includes left elements that have no correlation.
     *
     * @param this - The outer dataframe to join.
     * @param inner - The inner dataframe to join.
     * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
     * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
     * @param resultSelector - Selector that defines how to merge outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @returns Returns the joined dataframe.
     */
    joinOuterLeft<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerKeySelector: SelectorFn<ValueT, KeyT>, innerKeySelector: SelectorFn<InnerValueT, KeyT>, resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>): IDataFrame<number, ResultValueT>;
    /**
     * Performs a right outer join on two dataframes. Correlates the elements based on matching keys.
     * Includes right elements that have no correlation.
     *
     * @param this - The outer dataframe to join.
     * @param inner - The inner dataframe to join.
     * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
     * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
     * @param resultSelector - Selector that defines how to merge outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @returns Returns the joined dataframe.
     */
    joinOuterRight<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerKeySelector: SelectorFn<ValueT, KeyT>, innerKeySelector: SelectorFn<InnerValueT, KeyT>, resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>): IDataFrame<number, ResultValueT>;
    /**
     * Reshape (or pivot) a table based on column values.
     * This effiectively a short-hand for multiple grouping operations and an aggregation.
     *
     * @param columnOrColumns - Column name whose values make the new DataFrame's columns.
     * @param valueColumnNameOrSpec - Column name or column spec that defines the columns whose values should be aggregated.
     * @param [aggregator] - Optional function used to aggregate pivotted vales.
     *
     * @returns Returns a new dataframe that has been pivoted based on a particular column's values.
     */
    pivot<NewValueT = ValueT>(columnOrColumns: string | Iterable<string>, valueColumnNameOrSpec: string | IPivotAggregateSpec, aggregator?: (values: ISeries<number, any>) => any): IDataFrame<number, NewValueT>;
    /**
     * Insert a pair at the start of the dataframe.
     *
     * @param pair - The pair to insert.
     *
     * @returns Returns a new dataframe with the specified pair inserted.
     */
    insertPair(pair: [IndexT, ValueT]): IDataFrame<IndexT, ValueT>;
    /**
     * Append a pair to the end of a dataframe.
     *
     * @param pair - The pair to append.
     *
     * @returns Returns a new dataframe with the specified pair appended.
     */
    appendPair(pair: [IndexT, ValueT]): IDataFrame<IndexT, ValueT>;
    /**
     * Fill gaps in a dataframe.
     *
     * @param comparer - Comparer that is passed pairA and pairB, two consecutive rows, return truthy if there is a gap between the rows, or falsey if there is no gap.
     * @param generator - Generator that is passed pairA and pairB, two consecutive rows, returns an array of pairs that fills the gap between the rows.
     *
     * @returns Returns a new dataframe with gaps filled in.
     */
    fillGaps(comparer: ComparerFn<[IndexT, ValueT], [IndexT, ValueT]>, generator: GapFillFn<[IndexT, ValueT], [IndexT, ValueT]>): IDataFrame<IndexT, ValueT>;
    /**
     * Returns the specified default sequence if the dataframe is empty.
     *
     * @param defaultSequence - Default sequence to return if the dataframe is empty.
     *
     * @returns Returns 'defaultSequence' if the dataframe is empty.
     */
    defaultIfEmpty(defaultSequence: ValueT[] | IDataFrame<IndexT, ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Detect the types of the values in the dataframe.
     *
     * @returns Returns a dataframe that describes the data types contained in the input series or dataframe.
     */
    detectTypes(): IDataFrame<number, ITypeFrequency>;
    /**
     * Detect the frequency of the values in the dataframe.
     *
     * @returns Returns a dataframe that describes the values contained in the dataframe.
     */
    detectValues(): IDataFrame<number, IValueFrequency>;
    /**
     * Serialize the dataframe to JSON.
     *
     *  @returns Returns a JSON format string representing the dataframe.
     */
    toJSON(): string;
    /**
     * Serialize the dataframe to CSV.
     *
     *  @returns Returns a CSV format string representing the dataframe.
     */
    toCSV(): string;
    /**
     * Treat the dataframe as CSV data for purposes of serialization.
     *
     * @returns Returns an object that represents the dataframe for serialization in the CSV format. Call `writeFile`, `writeFileSync` to output the dataframe via different media.
     */
    asCSV(): ICsvSerializer;
    /**
     * Treat the dataframe as JSON data for purposes of serialization.
     *
     * @returns Returns an object that can serialize the dataframe in the JSON format. Call `writeFile` or `writeFileSync` to output the dataframe via different media.
     */
    asJSON(): IJsonSerializer;
    /**
     * Serialize the dataframe to HTML.
     *
     *  @returns Returns a HTML format string representing the dataframe.
     */
    toHTML(): string;
    /**
     * Serialize the dataframe to an ordinary JavaScript data structure.
     */
    serialize(): any;
}
/**
 * Interface to a dataframe that has been ordered.
 */
export interface IOrderedDataFrame<IndexT = number, ValueT = any, SortT = any> extends IDataFrame<IndexT, ValueT> {
    /**
     * Performs additional sorting (ascending).
     *
     * @param selector Selects the value to sort by.
     *
     * @returns Returns a new dataframe has been additionally sorted by the value returned by the selector.
     */
    thenBy<SortT>(selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;
    /**
     * Performs additional sorting (descending).
     *
     * @param selector Selects the value to sort by.
     *
     * @returns Returns a new dataframe has been additionally sorted by the value returned by the selector.
     */
    thenByDescending<SortT>(selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;
}
/**
 * Class that represents a dataframe.
 * A dataframe contains an indexed sequence of data records.
 * Think of it as a spreadsheet or CSV file in memory.
 *
 * Each data record contains multiple named fields, the value of each field represents one row in a column of data.
 * Each column of data is a named {@link Series}.
 * You think of a dataframe a collection of named data series.
 *
 * @typeparam IndexT The type to use for the index.
 * @typeparam ValueT The type to use for each row/data record.
 */
export declare class DataFrame<IndexT = number, ValueT = any> implements IDataFrame<IndexT, ValueT> {
    private configFn;
    private content;
    private static readonly defaultCountIterable;
    private static readonly defaultEmptyIterable;
    private static initFromArray<IndexT, ValueT>(arr);
    private static initEmpty<IndexT, ValueT>();
    private static initColumnNames(inputColumnNames);
    private static checkIterable<T>(input, fieldName);
    private static initFromConfig<IndexT, ValueT>(config);
    /**
     * Create a dataframe.
     *
     * @param config This can be an array, a configuration object or a function that lazily produces a configuration object.
     *
     * It can be an array that specifies the data records that the dataframe contains.
     *
     * It can be a {@link IDataFrameConfig} that defines the data and configuration of the dataframe.
     *
     * Or it can be a function that lazily produces a {@link IDataFrameConfig}.
     *
     * @example
     * const df = new DataFrame();
     * @example
     * const df = new DataFrame([10, 20, 30, 40]);
     * @example
     * const df = new DataFrame({ index: [1, 2, 3, 4], values: [10, 20, 30, 40]});
     * @example
     * <br/>
     * <pre>
     * const lazyInit = () => ({ index: [1, 2, 3, 4], values: [10, 20, 30, 40] });
     * const df = new DataFrame(lazyInit);
     * </pre>
     */
    constructor(config?: Iterable<ValueT> | IDataFrameConfig<IndexT, ValueT> | DataFrameConfigFn<IndexT, ValueT>);
    private lazyInit();
    private getContent();
    /**
     * Get an iterator to enumerate the values of the dataframe.
     * Enumerating the iterator forces lazy evaluation to complete.
     * This function is automatically called by `for...of`.
     *
     * @returns An iterator for the dataframe.
     *
     * @example
     * <br/>
     * <pre>
     * for (const row of df) {
     *     // ... do something with the row ...
     * }
     * </pre>
     */
    [Symbol.iterator](): Iterator<any>;
    /**
     * Get the names of the columns in the dataframe.
     *
     * @returns Returns an array of the column names in the dataframe.
     *
     * @example
     * console.log(df.getColumnNames());
     */
    getColumnNames(): string[];
    /**
     * Retreive a collection of all columns in the dataframe.
     *
     * @returns Returns a series the columns in the dataframe.
     */
    getColumns(): ISeries<number, IColumn>;
    /**
     * Cast the value of the dataframe to a new type.
     * This operation has no effect but to retype the value that the dataframe contains.
     */
    cast<NewValueT>(): IDataFrame<IndexT, NewValueT>;
    /**
     * Get the index for the dataframe.
     */
    getIndex(): IIndex<IndexT>;
    /**
     * Set a named column as the index of the data-frame.
     *
     * @param columnName - Name or index of the column to set as the index.
     *
     * @returns Returns a new dataframe with the values of a particular named column as the index.
     */
    setIndex<NewIndexT = any>(columnName: string): IDataFrame<NewIndexT, ValueT>;
    /**
     * Apply a new index to the dataframe.
     *
     * @param newIndex The new array or iterable to apply to the dataframe. Can also be a selector to choose the index for each row in the dataframe.
     *
     * @returns Returns a new dataframe or dataframe with the specified index attached.
     */
    withIndex<NewIndexT>(newIndex: Iterable<NewIndexT> | SelectorFn<ValueT, NewIndexT>): IDataFrame<NewIndexT, ValueT>;
    /**
     * Resets the index of the dataframe back to the default zero-based sequential integer index.
     *
     * @returns Returns a new dataframe with the index reset to the default zero-based index.
     */
    resetIndex(): IDataFrame<number, ValueT>;
    /**
     * Retreive a series from a column of the dataframe.
     *
     * @param columnName Specifies the name of the column that contains the series to retreive.
     */
    getSeries<SeriesValueT = any>(columnName: string): ISeries<IndexT, SeriesValueT>;
    /**
 * Returns true if the column with the requested name exists in the dataframe.
 *
 * @param columnName - Name of the column to check.
 */
    hasSeries(columnName: string): boolean;
    /**
     *
     * Verify the existance of a column and return it.
     * Throws an exception if the column doesn't exist.
     *
     * @param columnName - Name or index of the column to retreive.
     */
    expectSeries<SeriesValueT>(columnName: string): ISeries<IndexT, SeriesValueT>;
    /**
     * Create a new dataframe with an additional column specified by the passed-in series.
     *
     * @param columnNameOrSpec - The name of the column to add or replace.
     * @param [series] - When columnNameOrSpec is a string that identifies the column to add, this specifies the Series to add to the data-frame or a function that produces a series (given a dataframe).
     *
     * @returns Returns a new dataframe replacing or adding a particular named column.
     */
    withSeries<SeriesValueT>(columnNameOrSpec: string | IColumnGenSpec, series?: ISeries<IndexT, SeriesValueT> | SeriesSelectorFn<IndexT, ValueT, SeriesValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Add a series if it doesn't already exist.
     *
     * @param columnNameOrSpec - The name of the series to add or a column spec that defines the new column.
     * @param series - The series to add to the dataframe. Can also be a function that returns the series.
     *
     * @returns Returns a new dataframe with the specified series added, if the series didn't already exist. Otherwise if the requested series already exists the same dataframe is returned.
     */
    ensureSeries<SeriesValueT>(columnNameOrSpec: string | IColumnGenSpec, series?: ISeries<IndexT, SeriesValueT> | SeriesSelectorFn<IndexT, ValueT, SeriesValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Create a new data-frame from a subset of columns.
     *
     * @param columnNames - Array of column names to include in the new data-frame.
     *
     * @returns Returns a dataframe with a subset of columns from the input dataframe.
     */
    subset<NewValueT = ValueT>(columnNames: string[]): IDataFrame<IndexT, NewValueT>;
    /**
     * Create a new data frame with the requested column or columns dropped.
     *
     * @param columnOrColumns - Specifies the column name (a string) or columns (array of column names) to drop.
     *
     * @returns Returns a new dataframe with a particular name column or columns removed.
     */
    dropSeries<NewValueT = ValueT>(columnOrColumns: string | string[]): IDataFrame<IndexT, NewValueT>;
    /**
     * Create a new data frame with columns reordered.
     * New column names create new columns (with undefined values), omitting existing column names causes those columns to be dropped.
     *
     * @param columnNames - The new order for columns.
     *
     * @returns Returns a new dataframe with columns remapped according to the specified column layout.
     */
    reorderSeries<NewValueT = ValueT>(columnNames: string[]): IDataFrame<IndexT, NewValueT>;
    /**
     * Bring the name column (or columns) to the front, making it (or them) the first column(s) in the data-frame.
     *
     * @param columnOrColumns - Specifies the column or columns to bring to the front.
     *
     * @returns Returns a new dataframe with 1 or more columns bought to the front of the column ordering.
     */
    bringToFront(columnOrColumns: string | string[]): IDataFrame<IndexT, ValueT>;
    /**
     * Bring the name column (or columns) to the back, making it (or them) the last column(s) in the data-frame.
     *
     * @param columnOrColumns - Specifies the column or columns to bring to the back.
     *
     * @returns Returns a new dataframe with 1 or more columns bought to the back of the column ordering.
     */
    bringToBack(columnOrColumns: string | string[]): IDataFrame<IndexT, ValueT>;
    /**
     * Create a new data-frame with renamed series.
     *
     * @param newColumnNames - A column rename spec - maps existing column names to new column names.
     *
     * @returns Returns a new dataframe with columns renamed.
     */
    renameSeries<NewValueT = ValueT>(newColumnNames: IColumnRenameSpec): IDataFrame<IndexT, NewValueT>;
    /**
    * Extract values from the dataframe as an array.
    * This forces lazy evaluation to complete.
    *
    * @returns Returns an array of values contained within the dataframe.
    */
    toArray(): any[];
    /**
     * Retreive the index and values from the DataFrame as an array of pairs.
     * Each pair is [index, value].
     * This forces lazy evaluation to complete.
     *
     * @returns Returns an array of pairs that contains the dataframe content. Each pair is a two element array that contains an index and a value.
     */
    toPairs(): ([IndexT, ValueT])[];
    /**
     * Convert the dataframe to a JavaScript object.
     *
     * @param keySelector - Function that selects keys for the resulting object.
     * @param valueSelector - Function that selects values for the resulting object.
     *
     * @returns Returns a JavaScript object generated from the input sequence by the key and value selector funtions.
     */
    toObject<KeyT = any, FieldT = any, OutT = any>(keySelector: (value: ValueT) => KeyT, valueSelector: (value: ValueT) => FieldT): OutT;
    /**
     * Bake the data frame to an array of rows.
     *
     *  @returns Returns an array of rows. Each row is an array of values in column order.
     */
    toRows(): any[][];
    /**
     * Generate a new dataframe based by calling the selector function on each value.
     *
     * @param selector Selector function that transforms each value to create a new dataframe.
     *
     * @returns Returns a new dataframe that has been transformed by the selector function.
     */
    select<ToT>(selector: SelectorWithIndexFn<ValueT, ToT>): IDataFrame<IndexT, ToT>;
    /**
     * Generate a new dataframe based on the results of the selector function.
     *
     * @param selector Selector function that transforms each value into a list of values.
     *
     * @returns  Returns a new dataframe with values that have been produced by the selector function.
     */
    selectMany<ToT>(selector: SelectorWithIndexFn<ValueT, Iterable<ToT>>): IDataFrame<IndexT, ToT>;
    /**
     * Transform one or more columns. This is equivalent to extracting a column, calling 'select' on it,
     * then plugging it back in as the same column.
     *
     * @param columnSelectors - Object with field names for each column to be transformed. Each field you be a selector that transforms that column.
     *
     * @returns Returns a new dataframe with 1 or more columns transformed.
     */
    transformSeries<NewValueT = ValueT>(columnSelectors: IColumnTransformSpec): IDataFrame<IndexT, NewValueT>;
    /**
     * Generate new columns based on existing rows.
     *
     * @param generator - Generator function that transforms each row to a new set of columns.
     *
     * @returns Returns a new dataframe with 1 or more new columns.
     */
    generateSeries<NewValueT = ValueT>(generator: SelectorWithIndexFn<any, any> | IColumnTransformSpec): IDataFrame<IndexT, NewValueT>;
    /**
     * Deflate a data-frame to a series.
     *
     * @param [selector] - Optional selector function that transforms each row to a new sequence of values.
     *
     * @returns Returns a series that was created from the input dataframe.
     */
    deflate<ToT = ValueT>(selector?: SelectorWithIndexFn<ValueT, ToT>): ISeries<IndexT, ToT>;
    /**
     * Inflate a named series in the data-frame to 1 or more new series in the new dataframe.
     *
     * @param columnName - Name or index of the column to retreive.
     * @param [selector] - Optional selector function that transforms each value in the column to new columns. If not specified it is expected that each value in the column is an object whose fields define the new column names.
     *
     * @returns Returns a new dataframe with a column inflated to 1 or more new columns.
     */
    inflateSeries<NewValueT = ValueT>(columnName: string, selector?: SelectorWithIndexFn<IndexT, any>): IDataFrame<IndexT, ValueT>;
    /**
     * Segment a dataframe into 'windows'. Returns a new series. Each value in the new series contains a 'window' (or segment) of the original dataframe.
     * Use select or selectPairs to aggregate.
     *
     * @param period - The number of values in the window.
     *
     * @returns Returns a new series, each value of which is a 'window' (or segment) of the original dataframe.
     */
    window(period: number): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Segment a dataframe into 'rolling windows'. Returns a new series. Each value in the new series contains a 'window' (or segment) of the original series.
    *
     * @param period - The number of values in the window.
     *
     * @returns Returns a new series, each value of which is a 'window' (or segment) of the original series.
     */
    rollingWindow(period: number): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Groups sequential values into variable length 'windows'.
     *
     * @param comparer - Predicate that compares two values and returns true if they should be in the same window.
     *
     * @returns Returns a series of groups. Each group is itself a series that contains the values in the 'window'.
     */
    variableWindow(comparer: ComparerFn<ValueT, ValueT>): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Group sequential duplicate values into a series of windows.
     *
     * @param [selector] - Optional selector function to determine the value used to compare for duplicates.
     *
     * @returns Returns a series of groups. Each group is itself a series.
     */
    sequentialDistinct<ToT = ValueT>(selector?: SelectorFn<ValueT, ToT>): IDataFrame<IndexT, ValueT>;
    /**
     * Aggregate the values in the dataframe.
     *
     * @param [seed] - Optional seed value for producing the aggregation.
     * @param selector - Function that takes the seed and then each value in the dataframe and produces the aggregate value.
     *
     * @returns Returns a new value that has been aggregated from the input sequence by the 'selector' function.
     */
    aggregate<ToT = ValueT>(seedOrSelector: AggregateFn<ValueT, ToT> | ToT | IColumnAggregateSpec, selector?: AggregateFn<ValueT, ToT>): ToT;
    /**
     * Skip a number of values in the dataframe.
     *
     * @param numValues - Number of values to skip.
     * @returns Returns a new dataframe or dataframe with the specified number of values skipped.
     */
    skip(numValues: number): IDataFrame<IndexT, ValueT>;
    /**
     * Skips values in the series while a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series with all initial sequential values removed that match the predicate.
     */
    skipWhile(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Skips values in the series until a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series with all initial sequential values removed that don't match the predicate.
     */
    skipUntil(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Take a number of rows in the series.
     *
     * @param numRows - Number of rows to take.
     *
     * @returns Returns a new series with up to the specified number of values included.
     */
    take(numRows: number): IDataFrame<IndexT, ValueT>;
    /**
     * Take values from the series while a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series that only includes the initial sequential values that have matched the predicate.
     */
    takeWhile(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Take values from the series until a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series or dataframe that only includes the initial sequential values that have not matched the predicate.
     */
    takeUntil(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Count the number of values in the series.
     *
     * @returns Returns the count of all values in the series.
     */
    count(): number;
    /**
     * Get the first value of the series.
     *
     * @returns Returns the first value of the series.
     */
    first(): ValueT;
    /**
     * Get the last value of the series.
     *
     * @returns Returns the last value of the series.
     */
    last(): ValueT;
    /**
     * Get the value at a specified index.
     *
     * @param index - Index to for which to retreive the value.
     *
     * @returns Returns the value from the specified index in the sequence or undefined if there is no such index in the series.
     */
    at(index: IndexT): ValueT | undefined;
    /**
     * Get X values from the start of the dataframe.
     * Pass in a negative value to get all items at the head except X values at the tail.
     *
     * @param numValues - Number of values to take.
     *
     * @returns Returns a new dataframe that has only the specified number of values taken from the start of the input sequence.
     */
    head(numValues: number): IDataFrame<IndexT, ValueT>;
    /**
     * Get X values from the end of the dataframe.
     * Pass in a negative value to get all items at the tail except X values at the head.
     *
     * @param numValues - Number of values to take.
     *
     * @returns Returns a new dataframe that has only the specified number of values taken from the end of the input sequence.
     */
    tail(numValues: number): IDataFrame<IndexT, ValueT>;
    /**
     * Filter a series by a predicate selector.
     *
     * @param predicate - Predicte function to filter rows of the series.
     *
     * @returns Returns a new series containing only the values that match the predicate.
     */
    where(predicate: PredicateFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Invoke a callback function for each value in the series.
     *
     * @param callback - The calback to invoke for each value.
     *
     * @returns Returns the input series with no modifications.
     */
    forEach(callback: CallbackFn<ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Determine if the predicate returns truthy for all values in the series.
     * Returns false as soon as the predicate evaluates to falsy.
     * Returns true if the predicate returns truthy for all values in the series.
     * Returns false if the series is empty.
     *
     * @param predicate - Predicate function that receives each value in turn and returns truthy for a match, otherwise falsy.
     *
     * @returns {boolean} Returns true if the predicate has returned truthy for every value in the sequence, otherwise returns false.
     */
    all(predicate: PredicateFn<ValueT>): boolean;
    /**
     * Determine if the predicate returns truthy for any of the values in the series.
     * Returns true as soon as the predicate returns truthy.
     * Returns false if the predicate never returns truthy.
     * If no predicate is specified the value itself is checked.
     *
     * @param [predicate] - Optional predicate function that receives each value in turn and returns truthy for a match, otherwise falsy.
     *
     * @returns Returns true if the predicate has returned truthy for any value in the sequence, otherwise returns false.
     */
    any(predicate?: PredicateFn<ValueT>): boolean;
    /**
     * Determine if the predicate returns truthy for none of the values in the series.
     * Returns true for an empty series.
     * Returns true if the predicate always returns falsy.
     * Otherwise returns false.
     * If no predicate is specified the value itself is checked.
     *
     * @param [predicate] - Optional predicate function that receives each value in turn and returns truthy for a match, otherwise falsy.
     *
     * @returns Returns true if the predicate has returned truthy for no values in the series, otherwise returns false.
     */
    none(predicate?: PredicateFn<ValueT>): boolean;
    /**
     * Get a new series containing all values starting at and after the specified index value.
     *
     * @param indexValue - The index value to search for before starting the new series.
     *
     * @returns Returns a new series containing all values starting at and after the specified index value.
     */
    startAt(indexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Get a new series containing all values up until and including the specified index value (inclusive).
     *
     * @param indexValue - The index value to search for before ending the new series.
     *
     * @returns Returns a new series containing all values up until and including the specified index value.
     */
    endAt(indexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Get a new series containing all values up to the specified index value (exclusive).
     *
     * @param indexValue - The index value to search for before ending the new series.
     *
     * @returns Returns a new series containing all values up to the specified inde value.
     */
    before(indexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Get a new series containing all values after the specified index value (exclusive).
     *
     * @param indexValue - The index value to search for.
     *
     * @returns Returns a new series containing all values after the specified index value.
     */
    after(indexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Get a new dataframe containing all values between the specified index values (inclusive).
     *
     * @param startIndexValue - The index where the new sequence starts.
     * @param endIndexValue - The index where the new sequence ends.
     *
     * @returns Returns a new dataframe containing all values between the specified index values (inclusive).
     */
    between(startIndexValue: IndexT, endIndexValue: IndexT): IDataFrame<IndexT, ValueT>;
    /**
     * Format the dataframe for display as a string.
     * This forces lazy evaluation to complete.
     *
     * @returns Generates and returns a string representation of the dataframe or dataframe.
     */
    toString(): string;
    /**
     * Parse a column with string values to a column with int values.
     *
     * @param columnNameOrNames - Specifies the column name or array of column names to parse.
     *
     * @returns Returns a new dataframe with a particular named column parsed as ints.
     */
    parseInts(columnNameOrNames: string | string[]): IDataFrame<IndexT, ValueT>;
    /**
     * Parse a column with string values to a column with float values.
     *
     * @param columnNameOrNames - Specifies the column name or array of column names to parse.
     *
     * @returns  Returns a new dataframe with a particular named column parsed as floats.
     */
    parseFloats(columnNameOrNames: string | string[]): IDataFrame<IndexT, ValueT>;
    /**
     * Parse a column with string values to a column with date values.
     *
     * @param columnNameOrNames - Specifies the column name or array of column names to parse.
     * @param [formatString] - Optional formatting string for dates.
     *
     * @returns Returns a new dataframe with a particular named column parsed as dates.
     */
    parseDates(columnNameOrNames: string | string[], formatString?: string): IDataFrame<IndexT, ValueT>;
    /**
     * Convert a column of values of different types to a column of string values.
     *
     * @param columnNames - Specifies the column name or array of column names to convert to strings. Can also be a format spec that specifies which columns to convert and what their format should be.
     * @param [formatString] - Optional formatting string for dates.
     *
     * Numeral.js is used for number formatting.
     * http://numeraljs.com/
     *
     * Moment is used for date formatting.
     * https://momentjs.com/docs/#/parsing/string-format/
     *
     * @returns Returns a new dataframe with a particular named column convert to strings.
     */
    toStrings(columnNames: string | string[] | IFormatSpec, formatString?: string): IDataFrame<IndexT, ValueT>;
    /**
     * Produces a new data frame with all string values truncated to the requested maximum length.
     *
     * @param maxLength - The maximum length of the string values after truncation.
     *
     * @returns Returns a new dataframe with all strings truncated to the specified maximum length.
     */
    truncateStrings(maxLength: number): IDataFrame<IndexT, ValueT>;
    /**
     * Forces lazy evaluation to complete and 'bakes' the dataframe into memory.
     *
     * @returns Returns a dataframe that has been 'baked', all lazy evaluation has completed.
     */
    bake(): IDataFrame<IndexT, ValueT>;
    /**
     * Reverse the dataframe.
     *
     * @returns Returns a new dataframe that is the reverse of the input.
     */
    reverse(): IDataFrame<IndexT, ValueT>;
    /**
     * Returns only values in the dataframe that are distinct.
     *
     * @param selector - Selects the value used to compare for duplicates.
     *
     * @returns Returns a dataframe containing only unique values as determined by the 'selector' function.
     */
    distinct<ToT>(selector?: SelectorFn<ValueT, ToT>): IDataFrame<IndexT, ValueT>;
    /**
     * Groups the dataframe according to the selector.
     *
     * @param selector - Selector that defines the value to group by.
     *
     * @returns Returns a series of groups. Each group is a series with values that have been grouped by the 'selector' function.
     */
    groupBy<GroupT>(selector: SelectorWithIndexFn<ValueT, GroupT>): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Group sequential values into a series of windows.
     *
     * @param selector - Optional selector that defines the value to group by.
     *
     * @returns Returns a series of groups. Each group is a dataframe with values that have been grouped by the 'selector' function.
     */
    groupSequentialBy<GroupT>(selector?: SelectorFn<ValueT, GroupT>): ISeries<number, IDataFrame<IndexT, ValueT>>;
    /**
     * Concatenate multiple dataframes into a single dataframe.
     *
     * @param dataframes - Array of dataframes to concatenate.
     *
     * @returns Returns a single dataframe concatenated from multiple input dataframes.
     */
    static concat<IndexT = any, ValueT = any>(dataframes: IDataFrame<IndexT, ValueT>[]): IDataFrame<IndexT, ValueT>;
    /**
     * Concatenate multiple other dataframes onto this dataframe.
     *
     * @param dataframes - Multiple arguments. Each can be either a dataframe or an array of dataframes.
     *
     * @returns Returns a single dataframes concatenated from multiple input dataframes.
     */
    concat(...dataframes: (IDataFrame<IndexT, ValueT>[] | IDataFrame<IndexT, ValueT>)[]): IDataFrame<IndexT, ValueT>;
    /**
    * Zip together multiple dataframes to create a new dataframe.
    * Preserves the index of the first dataframe.
    *
    * @param dataframes - Multiple arguments. Each can be either a dataframe or an array of dataframes.
    * @param zipper - Selector function that produces a new dataframe based on the input dataframes.
    *
    * @returns Returns a single dataframe zipped from multiple input dataframes.
    */
    static zip<IndexT = any, ValueT = any, ResultT = any>(dataframes: IDataFrame<IndexT, ValueT>[], zipper: ZipNFn<ValueT, ResultT>): IDataFrame<IndexT, ResultT>;
    /**
    * Zip together multiple dataframes to create a new dataframe.
    * Preserves the index of the first dataframe.
    *
    * @param s2, s3, s4, s4 - Multiple dataframes to zip.
    * @param zipper - Zipper function that produces a new dataframe based on the input dataframes.
    *
    * @returns Returns a single dataframe concatenated from multiple input dataframes.
    */
    zip<Index2T, Value2T, ResultT>(s2: IDataFrame<Index2T, Value2T>, zipper: Zip2Fn<ValueT, Value2T, ResultT>): IDataFrame<IndexT, ResultT>;
    zip<Index2T, Value2T, Index3T, Value3T, ResultT>(s2: IDataFrame<Index2T, Value2T>, s3: IDataFrame<Index3T, Value3T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT>): IDataFrame<IndexT, ResultT>;
    zip<Index2T, Value2T, Index3T, Value3T, Index4T, Value4T, ResultT>(s2: IDataFrame<Index2T, Value2T>, s3: IDataFrame<Index3T, Value3T>, s4: IDataFrame<Index4T, Value4T>, zipper: Zip3Fn<ValueT, Value2T, Value3T, ResultT>): IDataFrame<IndexT, ResultT>;
    /**
     * Sorts the dataframe by a value defined by the selector (ascending).
     *
     * @param selector Selects the value to sort by.
     *
     * @returns Returns a new ordered dataframe that has been sorted by the value returned by the selector.
     */
    orderBy<SortT>(selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;
    /**
     * Sorts the dataframe by a value defined by the selector (descending).
     *
     * @param selector Selects the value to sort by.
     *
     * @returns Returns a new ordered dataframe that has been sorted by the value returned by the selector.
     */
    orderByDescending<SortT>(selector: SelectorWithIndexFn<ValueT, SortT>): IOrderedDataFrame<IndexT, ValueT, SortT>;
    /**
     * Returns the unique union of values between two dataframes.
     *
     * @param other - The other dataframes to combine.
     * @param [selector] - Optional function that selects the value to compare to detemrine distinctness.
     *
     * @returns Returns the union of two dataframes.
     */
    union<KeyT = ValueT>(other: IDataFrame<IndexT, ValueT>, selector?: SelectorFn<ValueT, KeyT>): IDataFrame<IndexT, ValueT>;
    /**
     * Returns the intersection of values between two dataframes.
     *
     * @param inner - The other dataframe to combine.
     * @param [outerSelector] - Optional function to select the key for matching the two dataframes.
     * @param [innerSelector] - Optional function to select the key for matching the two dataframes.
     *
     * @returns Returns the intersection of two series.
     */
    intersection<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerSelector?: SelectorFn<ValueT, KeyT>, innerSelector?: SelectorFn<InnerValueT, KeyT>): IDataFrame<IndexT, ValueT>;
    /**
     * Returns the exception of values between two dataframes.
     *
     * @param inner - The other dataframe to combine.
     * @param [outerSelector] - Optional function to select the key for matching the two dataframes.
     * @param [innerSelector] - Optional function to select the key for matching the two dataframes.
     *
     * @returns Returns the difference between the two series.
     */
    except<InnerIndexT = IndexT, InnerValueT = ValueT, KeyT = ValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerSelector?: SelectorFn<ValueT, KeyT>, innerSelector?: SelectorFn<InnerValueT, KeyT>): IDataFrame<IndexT, ValueT>;
    /**
      * Correlates the elements of two dataframes on matching keys.
      *
      * @param this - The outer dataframe to join.
      * @param inner - The inner dataframe to join.
      * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
      * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
      * @param resultSelector - Selector that defines how to merge outer and inner values.
      *
      * @returns Returns the joined dataframe.
      */
    join<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerKeySelector: SelectorFn<ValueT, KeyT>, innerKeySelector: SelectorFn<InnerValueT, KeyT>, resultSelector: JoinFn<ValueT, InnerValueT, ResultValueT>): IDataFrame<number, ResultValueT>;
    /**
     * Performs an outer join on two series. Correlates the elements based on matching keys.
     * Includes elements from both series that have no correlation in the other series.
     *
     * @param this - The outer series to join.
     * @param inner - The inner series to join.
     * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
     * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
     * @param resultSelector - Selector that defines how to merge outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @returns Returns the joined series.
     */
    joinOuter<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerKeySelector: SelectorFn<ValueT, KeyT>, innerKeySelector: SelectorFn<InnerValueT, KeyT>, resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>): IDataFrame<number, ResultValueT>;
    /**
     * Performs a left outer join on two dataframes. Correlates the elements based on matching keys.
     * Includes left elements that have no correlation.
     *
     * @param this - The outer dataframe to join.
     * @param inner - The inner dataframe to join.
     * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
     * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
     * @param resultSelector - Selector that defines how to merge outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @returns Returns the joined dataframes.
     */
    joinOuterLeft<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerKeySelector: SelectorFn<ValueT, KeyT>, innerKeySelector: SelectorFn<InnerValueT, KeyT>, resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>): IDataFrame<number, ResultValueT>;
    /**
     * Performs a right outer join on two dataframes. Correlates the elements based on matching keys.
     * Includes right elements that have no correlation.
     *
     * @param this - The outer dataframe to join.
     * @param inner - The inner dataframe to join.
     * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
     * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
     * @param resultSelector - Selector that defines how to merge outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @returns Returns the joined dataframes.
     */
    joinOuterRight<KeyT, InnerIndexT, InnerValueT, ResultValueT>(inner: IDataFrame<InnerIndexT, InnerValueT>, outerKeySelector: SelectorFn<ValueT, KeyT>, innerKeySelector: SelectorFn<InnerValueT, KeyT>, resultSelector: JoinFn<ValueT | null, InnerValueT | null, ResultValueT>): IDataFrame<number, ResultValueT>;
    /**
     * Reshape (or pivot) a table based on column values.
     * This effiectively a short-hand for multiple grouping operations and an aggregation.
     *
     * @param columnOrColumns - Column name whose values make the new DataFrame's columns.
     * @param valueColumnNameOrSpec - Column name or column spec that defines the columns whose values should be aggregated.
     * @param [aggregator] - Optional function used to aggregate pivotted vales.
     *
     * @returns Returns a new dataframe that has been pivoted based on a particular column's values.
     */
    pivot<NewValueT = ValueT>(columnOrColumns: string | Iterable<string>, valueColumnNameOrSpec: string | IPivotAggregateSpec, aggregator?: (values: ISeries<number, any>) => any): IDataFrame<number, NewValueT>;
    /**
     * Insert a pair at the start of the dataframe.
     *
     * @param pair - The pair to insert.
     *
     * @returns Returns a new dataframe with the specified pair inserted.
     */
    insertPair(pair: [IndexT, ValueT]): IDataFrame<IndexT, ValueT>;
    /**
     * Append a pair to the end of a dataframe.
     *
     * @param pair - The pair to append.
     *
     * @returns Returns a new dataframe with the specified pair appended.
     */
    appendPair(pair: [IndexT, ValueT]): IDataFrame<IndexT, ValueT>;
    /**
     * Fill gaps in a dataframe.
     *
     * @param comparer - Comparer that is passed pairA and pairB, two consecutive rows, return truthy if there is a gap between the rows, or falsey if there is no gap.
     * @param generator - Generator that is passed pairA and pairB, two consecutive rows, returns an array of pairs that fills the gap between the rows.
     *
     * @returns Returns a new dataframe with gaps filled in.
     */
    fillGaps(comparer: ComparerFn<[IndexT, ValueT], [IndexT, ValueT]>, generator: GapFillFn<[IndexT, ValueT], [IndexT, ValueT]>): IDataFrame<IndexT, ValueT>;
    /**
     * Returns the specified default sequence if the dataframe is empty.
     *
     * @param defaultSequence - Default sequence to return if the dataframe is empty.
     *
     * @returns Returns 'defaultSequence' if the dataframe is empty.
     */
    defaultIfEmpty(defaultSequence: ValueT[] | IDataFrame<IndexT, ValueT>): IDataFrame<IndexT, ValueT>;
    /**
     * Detect the the frequency of the types of the values in the dataframe.
     *
     * @returns Returns a dataframe that describes the data types contained in the dataframe.
     */
    detectTypes(): IDataFrame<number, ITypeFrequency>;
    /**
     * Detect the frequency of the values in the dataframe.
     *
     * @returns Returns a dataframe that describes the values contained in the dataframe.
     */
    detectValues(): IDataFrame<number, IValueFrequency>;
    /**
     * Serialize the dataframe to JSON.
     *
     *  @returns Returns a JSON format string representing the dataframe.
     */
    toJSON(): string;
    /**
     * Serialize the dataframe to CSV.
     *
     *  @returns Returns a CSV format string representing the dataframe.
     */
    toCSV(): string;
    /**
     * Treat the dataframe as CSV data for purposes of serialization.
     *
     * @returns Returns an object that represents the dataframe for serialization in the CSV format. Call `writeFile`, `writeFileSync` to output the dataframe via different media.
     */
    asCSV(): ICsvSerializer;
    /**
     * Treat the dataframe as JSON data for purposes of serialization.
     *
     * @returns Returns an object that can serialize the dataframe in the JSON format. Call `writeFile` or `writeFileSync` to output the dataframe via different media.
     */
    asJSON(): IJsonSerializer;
    /**
     * Serialize the data frame to HTML.
     *
     *  @returns Returns a HTML format string representing the dataframe.
     */
    toHTML(): string;
    /**
     * Serialize the dataframe to an ordinary JavaScript data structure.
     */
    serialize(): any;
    /**
     * Deserialize the dataframe from an ordinary JavaScript data structure.
     */
    static deserialize<IndexT = any, ValueT = any>(input: any): IDataFrame<IndexT, ValueT>;
}
/**
 * Packages a dataframe ready for CSV serialization.
 * */
export interface ICsvSerializer {
    /**
     * Serialize the dataframe to a CSV file in the local file system.
     * Asynchronous version.
     *
     * @param filePath - Specifies the output path for the file.
     *
     *  @returns Returns a promise that resolves when the file has been written.
     */
    writeFile(filePath: string): Promise<void>;
    /**
     * Serialize the dataframe to a CSV file in the local file system.
     * Synchronous version.
     *
     * @param filePath - Specifies the output path for the file.
     */
    writeFileSync(filePath: string): void;
}
/**
 * Packages a dataframe ready for JSON serialization.
 */
export interface IJsonSerializer {
    /**
     * Serialize the dataframe to a JSON file in the local file system.
     * Asynchronous version.
     *
     * @param filePath - Specifies the output path for the file.
     *
     *  @returns Returns a promise that resolves when the file has been written.
     */
    writeFile(filePath: string): Promise<void>;
    /**
     * Serialize the dataframe to a JSON file in the local file system.
     * Synchronous version.
     *
     * @param filePath - Specifies the output path for the file.
     */
    writeFileSync(filePath: string): void;
}
