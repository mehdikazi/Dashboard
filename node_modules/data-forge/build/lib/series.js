"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var empty_iterable_1 = require("./iterables/empty-iterable");
var count_iterable_1 = require("./iterables/count-iterable");
var multi_iterable_1 = require("./iterables/multi-iterable");
var select_iterable_1 = require("./iterables/select-iterable");
var select_many_iterable_1 = require("./iterables/select-many-iterable");
var take_iterable_1 = require("./iterables/take-iterable");
var take_while_iterable_1 = require("./iterables/take-while-iterable");
var where_iterable_1 = require("./iterables/where-iterable");
var concat_iterable_1 = require("./iterables/concat-iterable");
var series_window_iterable_1 = require("./iterables/series-window-iterable");
var reverse_iterable_1 = require("./iterables/reverse-iterable");
var zip_iterable_1 = require("./iterables/zip-iterable");
var distinct_iterable_1 = require("./iterables/distinct-iterable");
var series_rolling_window_iterable_1 = require("./iterables/series-rolling-window-iterable");
var series_variable_window_iterable_1 = require("./iterables/series-variable-window-iterable");
var ordered_iterable_1 = require("./iterables/ordered-iterable");
var Sugar = require("sugar");
var index_1 = require("./index");
var extract_element_iterable_1 = require("./iterables/extract-element-iterable");
var skip_iterable_1 = require("./iterables/skip-iterable");
var skip_while_iterable_1 = require("./iterables/skip-while-iterable");
var Table = require('easy-table');
var chai_1 = require("chai");
var dataframe_1 = require("./dataframe");
var moment = require("moment");
var utils_1 = require("./utils");
var __1 = require("..");
var numeral = require("numeral");
;
/**
 * Class that represents a series containing a sequence of indexed values.
 */
var Series = /** @class */ (function () {
    /**
     * Create a series.
     *
     * @param config This can be either an array or a config object the sets the values that the series contains.
     * If it is an array it specifies the values that the series contains.
     * If it is a config object that can contain:
     *      values: Optional array or iterable of values that the series contains.
     *      index: Optional array or iterable of values that index the series, defaults to a series of integers from 1 and counting upward.
     *      pairs: Optional iterable of pairs (index and value) that the series contains.
     */
    function Series(config) {
        //
        // Function to lazy evaluate the configuration of the series.
        //
        this.configFn = null;
        //
        // The content of the series.
        // When this is null it means the series is yet to be lazy initialised.
        //
        this.content = null;
        if (config) {
            if (Sugar.Object.isFunction(config)) {
                this.configFn = config;
            }
            else if (Sugar.Object.isArray(config) ||
                Sugar.Object.isFunction(config[Symbol.iterator])) {
                this.content = Series.initFromArray(config);
            }
            else {
                this.content = Series.initFromConfig(config);
            }
        }
        else {
            this.content = Series.initEmpty();
        }
    }
    //
    // Initialise series content from an array of values.
    //
    Series.initFromArray = function (arr) {
        return {
            index: Series.defaultCountIterable,
            values: arr,
            pairs: new multi_iterable_1.MultiIterable([Series.defaultCountIterable, arr]),
            isBaked: true,
        };
    };
    //
    // Initialise an empty series.
    //
    Series.initEmpty = function () {
        return {
            index: Series.defaultEmptyIterable,
            values: Series.defaultEmptyIterable,
            pairs: Series.defaultEmptyIterable,
            isBaked: true,
        };
    };
    //
    // Check that a value is an interable.
    //
    Series.checkIterable = function (input, fieldName) {
        if (Sugar.Object.isArray(input)) {
            // Ok
        }
        else if (Sugar.Object.isFunction(input[Symbol.iterator])) {
            // Assume it's an iterable.
            // Ok
        }
        else {
            // Not ok
            throw new Error("Expected '" + fieldName + "' field of Series config object to be an array of values or an iterable of values.");
        }
    };
    ;
    //
    // Initialise series content from a config object.
    //
    Series.initFromConfig = function (config) {
        var index;
        var values;
        var pairs;
        var isBaked = false;
        if (config.pairs) {
            Series.checkIterable(config.pairs, "pairs");
            pairs = config.pairs;
        }
        if (config.index) {
            Series.checkIterable(config.index, "index");
            index = config.index;
        }
        else if (pairs) {
            index = new extract_element_iterable_1.ExtractElementIterable(pairs, 0);
        }
        else {
            index = Series.defaultCountIterable;
        }
        if (config.values) {
            Series.checkIterable(config.values, "values");
            values = config.values;
        }
        else if (pairs) {
            values = new extract_element_iterable_1.ExtractElementIterable(pairs, 1);
        }
        else {
            values = Series.defaultEmptyIterable;
        }
        if (!pairs) {
            pairs = new multi_iterable_1.MultiIterable([index, values]);
        }
        if (config.baked !== undefined) {
            isBaked = config.baked;
        }
        return {
            index: index,
            values: values,
            pairs: pairs,
            isBaked: isBaked,
        };
    };
    //
    // Ensure the series content has been initialised.
    //
    Series.prototype.lazyInit = function () {
        if (this.content === null && this.configFn !== null) {
            this.content = Series.initFromConfig(this.configFn());
        }
    };
    //
    // Ensure the series content is lazy initalised and return it.
    //
    Series.prototype.getContent = function () {
        this.lazyInit();
        return this.content;
    };
    /**
     * Get an iterator to enumerate the values of the series.
     * Enumerating the iterator forces lazy evaluation to complete.
     */
    Series.prototype[Symbol.iterator] = function () {
        return this.getContent().values[Symbol.iterator]();
    };
    /**
     * Cast the value of the series to a new type.
     * This operation has no effect but to retype the value that the series contains.
     */
    Series.prototype.cast = function () {
        return this;
    };
    /**
     * Get the index for the series.
     */
    Series.prototype.getIndex = function () {
        var _this = this;
        return new index_1.Index(function () { return ({ values: _this.getContent().index }); });
    };
    /**
     * Apply a new index to the Series.
     *
     * @param newIndex The new array or iterable to apply to the dataframe. Can also be a selector to choose the index for each row in the dataframe.
     *
     * @returns Returns a new series with the specified index attached.
     */
    Series.prototype.withIndex = function (newIndex) {
        var _this = this;
        if (Sugar.Object.isFunction(newIndex)) {
            return new Series(function () { return ({
                values: _this.getContent().values,
                index: _this.select(newIndex),
            }); });
        }
        else {
            Series.checkIterable(newIndex, 'newIndex');
            return new Series(function () { return ({
                values: _this.getContent().values,
                index: newIndex,
            }); });
        }
    };
    ;
    /**
     * Resets the index of the series back to the default zero-based sequential integer index.
     *
     * @returns Returns a new series with the index reset to the default zero-based index.
     */
    Series.prototype.resetIndex = function () {
        var _this = this;
        return new Series(function () { return ({
            values: _this.getContent().values // Just strip the index.
        }); });
    };
    /**
    * Extract values from the series as an array.
    * This forces lazy evaluation to complete.
    *
    * @returns Returns an array of values contained within the series.
    */
    Series.prototype.toArray = function () {
        var values = [];
        try {
            for (var _a = __values(this.getContent().values), _b = _a.next(); !_b.done; _b = _a.next()) {
                var value = _b.value;
                if (value !== undefined) {
                    values.push(value);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return values;
        var e_1, _c;
    };
    /**
     * Retreive the index and values from the Series as an array of pairs.
     * Each pair is [index, value].
     * This forces lazy evaluation to complete.
     *
     * @returns Returns an array of pairs that contains the series content. Each pair is a two element array that contains an index and a value.
     */
    Series.prototype.toPairs = function () {
        var pairs = [];
        try {
            for (var _a = __values(this.getContent().pairs), _b = _a.next(); !_b.done; _b = _a.next()) {
                var pair = _b.value;
                if (pair[1] != undefined) {
                    pairs.push(pair);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return pairs;
        var e_2, _c;
    };
    /**
     * Convert the series to a JavaScript object.
     *
     * @param keySelector - Function that selects keys for the resulting object.
     * @param valueSelector - Function that selects values for the resulting object.
     *
     * @returns {object} Returns a JavaScript object generated from the input sequence by the key and value selector funtions.
     */
    Series.prototype.toObject = function (keySelector, valueSelector) {
        chai_1.assert.isFunction(keySelector, "Expected 'keySelector' parameter to Series.toObject to be a function.");
        chai_1.assert.isFunction(valueSelector, "Expected 'valueSelector' parameter to Series.toObject to be a function.");
        return utils_1.toMap(this, keySelector, valueSelector);
    };
    /**
     * Generate a new series based by calling the selector function on each value.
     *
     * @param selector Selector function that transforms each value to create a new series.
     *
     * @returns Returns a new series that has been transformed by the selector function.
     */
    Series.prototype.select = function (selector) {
        var _this = this;
        chai_1.assert.isFunction(selector, "Expected 'selector' parameter to 'Series.select' function to be a function.");
        return new Series(function () { return ({
            values: new select_iterable_1.SelectIterable(_this.getContent().values, selector),
            index: _this.getContent().index,
        }); });
    };
    /**
     * Generate a new series based on the results of the selector function.
     *
     * @param selector Selector function that transforms each value into a list of values.
     *
     * @returns  Returns a new series with values that have been produced by the selector function.
     */
    Series.prototype.selectMany = function (selector) {
        var _this = this;
        chai_1.assert.isFunction(selector, "Expected 'selector' parameter to 'Series.selectMany' to be a function.");
        return new Series(function () { return ({
            pairs: new select_many_iterable_1.SelectManyIterable(_this.getContent().pairs, function (pair, index) {
                var outputPairs = [];
                try {
                    for (var _a = __values(selector(pair[1], index)), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var transformed = _b.value;
                        outputPairs.push([
                            pair[0],
                            transformed
                        ]);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                return outputPairs;
                var e_3, _c;
            })
        }); });
    };
    /**
     * Segment a series into 'windows'. Returns a new series. Each value in the new series contains a 'window' (or segment) of the original series.
     * Use select or selectPairs to aggregate.
     *
     * @param period - The number of values in the window.
     *
     * @returns Returns a new series, each value of which is a 'window' (or segment) of the original series.
     */
    Series.prototype.window = function (period) {
        var _this = this;
        chai_1.assert.isNumber(period, "Expected 'period' parameter to 'Series.window' to be a number.");
        return new Series(function () { return ({
            values: new series_window_iterable_1.SeriesWindowIterable(_this.getContent().pairs, period)
        }); });
    };
    /**
     * Segment a series into 'rolling windows'. Returns a new series. Each value in the new series contains a 'window' (or segment) of the original series.
    *
     * @param period - The number of values in the window.
     *
     * @returns Returns a new series, each value of which is a 'window' (or segment) of the original series.
     */
    Series.prototype.rollingWindow = function (period) {
        var _this = this;
        chai_1.assert.isNumber(period, "Expected 'period' parameter to 'Series.rollingWindow' to be a number.");
        return new Series(function () { return ({
            values: new series_rolling_window_iterable_1.SeriesRollingWindowIterable(_this.getContent().pairs, period)
        }); });
    };
    /**
     * Groups sequential values into variable length 'windows'.
     *
     * @param comparer - Predicate that compares two values and returns true if they should be in the same window.
     *
     * @returns Returns a series of groups. Each group is itself a series that contains the values in the 'window'.
     */
    Series.prototype.variableWindow = function (comparer) {
        var _this = this;
        chai_1.assert.isFunction(comparer, "Expected 'comparer' parameter to 'Series.variableWindow' to be a function.");
        return new Series(function () { return ({
            values: new series_variable_window_iterable_1.SeriesVariableWindowIterable(_this.getContent().pairs, comparer)
        }); });
    };
    ;
    /**
     * Collapase distinct values that happen to be sequential.
     *
     * @param [selector] - Optional selector function to determine the value used to compare for duplicates.
     *
     * @returns Returns a new series with duplicate values that are sequential removed.
     */
    Series.prototype.sequentialDistinct = function (selector) {
        if (selector) {
            chai_1.assert.isFunction(selector, "Expected 'selector' parameter to 'Series.sequentialDistinct' to be a selector function that determines the value to compare for duplicates.");
        }
        else {
            selector = function (value) { return value; };
        }
        return this.variableWindow(function (a, b) { return selector(a) === selector(b); })
            .select(function (window) {
            return [window.getIndex().first(), window.first()];
        })
            .withIndex(function (pair) { return pair[0]; })
            .select(function (pair) { return pair[1]; });
    };
    /**
     * Aggregate the values in the series.
     *
     * @param [seed] - Optional seed value for producing the aggregation.
     * @param selector - Function that takes the seed and then each value in the series and produces the aggregate value.
     *
     * @returns Returns a new value that has been aggregated from the input sequence by the 'selector' function.
     */
    Series.prototype.aggregate = function (seedOrSelector, selector) {
        if (Sugar.Object.isFunction(seedOrSelector) && !selector) {
            return this.skip(1).aggregate(this.first(), seedOrSelector);
        }
        else {
            chai_1.assert.isFunction(selector, "Expected 'selector' parameter to aggregate to be a function.");
            var accum = seedOrSelector;
            try {
                for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var value = _b.value;
                    accum = selector(accum, value);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_4) throw e_4.error; }
            }
            return accum;
        }
        var e_4, _c;
    };
    /**
     * Compute the amount of change between each pair of values.
     *
     * @param [period] - Optional period for computing the change - defaults to 2.
     *
     * @returns Returns a new series where each value indicates the amount of change from the previous number value in the original series.
     */
    Series.prototype.amountChange = function (period) {
        return this // Have to assume this is a number series.
            .rollingWindow(period === undefined ? 2 : period)
            .select(function (window) {
            var first = window.first();
            var last = window.last();
            var amountChange = last - first; // Compute amount of change.
            return [window.getIndex().last(), amountChange]; // Return new index and value.
        })
            .withIndex(function (pair) { return pair[0]; })
            .select(function (pair) { return pair[1]; });
    };
    /**
     * Compute the proportion change between each pair of values.
     * Proportions are expressed as 0-1 values.
     *
     * @param [period] - Optional period for computing the proportion - defaults to 2.
     *
     * @returns Returns a new series where each value indicates the proportion change from the previous number value in the original series.
     */
    Series.prototype.proportionChange = function (period) {
        return this // Have to assume this is a number series.
            .rollingWindow(period === undefined ? 2 : period)
            .select(function (window) {
            var first = window.first();
            var last = window.last();
            var amountChange = last - first; // Compute amount of change.
            var pctChange = amountChange / first; // Compute proportion change.
            return [window.getIndex().last(), pctChange]; // Return new index and value.
        })
            .withIndex(function (pair) { return pair[0]; })
            .select(function (pair) { return pair[1]; });
    };
    /**
     * Compute the percent change between each pair of values.
     * Percentages are expressed as 0-100 values.
     *
     * @param [period] - Optional period for computing the percentage - defaults to 2.
     *
     * @returns Returns a new series where each value indicates the percent change from the previous number value in the original series.
     */
    Series.prototype.percentChange = function (period) {
        return this.proportionChange(period).select(function (v) { return v * 100; });
    };
    /**
     * Skip a number of values in the series.
     *
     * @param numValues - Number of values to skip.     *
     * @returns Returns a new series or dataframe with the specified number of values skipped.
     */
    Series.prototype.skip = function (numValues) {
        var _this = this;
        return new Series(function () { return ({
            values: new skip_iterable_1.SkipIterable(_this.getContent().values, numValues),
            index: new skip_iterable_1.SkipIterable(_this.getContent().index, numValues),
            pairs: new skip_iterable_1.SkipIterable(_this.getContent().pairs, numValues),
        }); });
    };
    /**
     * Skips values in the series while a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series with all initial sequential values removed that match the predicate.
     */
    Series.prototype.skipWhile = function (predicate) {
        var _this = this;
        chai_1.assert.isFunction(predicate, "Expected 'predicate' parameter to 'Series.skipWhile' function to be a predicate function that returns true/false.");
        return new Series(function () { return ({
            values: new skip_while_iterable_1.SkipWhileIterable(_this.getContent().values, predicate),
            pairs: new skip_while_iterable_1.SkipWhileIterable(_this.getContent().pairs, function (pair) { return predicate(pair[1]); }),
        }); });
    };
    /**
     * Skips values in the series until a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series with all initial sequential values removed that don't match the predicate.
     */
    Series.prototype.skipUntil = function (predicate) {
        chai_1.assert.isFunction(predicate, "Expected 'predicate' parameter to 'Series.skipUntil' function to be a predicate function that returns true/false.");
        return this.skipWhile(function (value) { return !predicate(value); });
    };
    /**
     * Take a number of rows in the series.
     *
     * @param numRows - Number of rows to take.
     *
     * @returns Returns a new series with up to the specified number of values included.
     */
    Series.prototype.take = function (numRows) {
        var _this = this;
        chai_1.assert.isNumber(numRows, "Expected 'numRows' parameter to 'Series.take' function to be a number.");
        return new Series(function () { return ({
            index: new take_iterable_1.TakeIterable(_this.getContent().index, numRows),
            values: new take_iterable_1.TakeIterable(_this.getContent().values, numRows),
            pairs: new take_iterable_1.TakeIterable(_this.getContent().pairs, numRows)
        }); });
    };
    ;
    /**
     * Take values from the series while a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series that only includes the initial sequential values that have matched the predicate.
     */
    Series.prototype.takeWhile = function (predicate) {
        var _this = this;
        chai_1.assert.isFunction(predicate, "Expected 'predicate' parameter to 'Series.takeWhile' function to be a predicate function that returns true/false.");
        return new Series(function () { return ({
            values: new take_while_iterable_1.TakeWhileIterable(_this.getContent().values, predicate),
            pairs: new take_while_iterable_1.TakeWhileIterable(_this.getContent().pairs, function (pair) { return predicate(pair[1]); })
        }); });
    };
    /**
     * Take values from the series until a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series or dataframe that only includes the initial sequential values that have not matched the predicate.
     */
    Series.prototype.takeUntil = function (predicate) {
        chai_1.assert.isFunction(predicate, "Expected 'predicate' parameter to 'Series.takeUntil' function to be a predicate function that returns true/false.");
        return this.takeWhile(function (value) { return !predicate(value); });
    };
    /**
     * Count the number of values in the series.
     *
     * @returns Returns the count of all values in the series.
     */
    Series.prototype.count = function () {
        var total = 0;
        try {
            for (var _a = __values(this.getContent().values), _b = _a.next(); !_b.done; _b = _a.next()) {
                var value = _b.value;
                ++total;
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return total;
        var e_5, _c;
    };
    /**
     * Get the first value of the series.
     *
     * @returns Returns the first value of the series.
     */
    Series.prototype.first = function () {
        try {
            for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                var value = _b.value;
                return value; // Only need the first value.
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_6) throw e_6.error; }
        }
        throw new Error("No values in Series.");
        var e_6, _c;
    };
    /**
     * Get the last value of the series.
     *
     * @returns Returns the last value of the series.
     */
    Series.prototype.last = function () {
        var lastValue = null;
        try {
            for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                var value = _b.value;
                lastValue = value; // Throw away all values until we get to the last one.
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_7) throw e_7.error; }
        }
        if (lastValue === null) {
            throw new Error("No values in Series.");
        }
        return lastValue;
        var e_7, _c;
    };
    /**
     * Get the value at a specified index.
     *
     * @param index - Index to for which to retreive the value.
     *
     * @returns Returns the value from the specified index in the sequence or undefined if there is no such index in the series.
     */
    Series.prototype.at = function (index) {
        if (this.none()) {
            return undefined;
        }
        try {
            //
            // This is pretty expensive.
            // A specialised index could improve this.
            //
            for (var _a = __values(this.getContent().pairs), _b = _a.next(); !_b.done; _b = _a.next()) {
                var pair = _b.value;
                if (pair[0] === index) {
                    return pair[1];
                }
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_8) throw e_8.error; }
        }
        return undefined;
        var e_8, _c;
    };
    /**
     * Get X values from the start of the series.
     * Pass in a negative value to get all items at the head except X values at the tail.
     *
     * @param numValues - Number of values to take.
     *
     * @returns Returns a new series that has only the specified number of values taken from the start of the input sequence.
     */
    Series.prototype.head = function (numValues) {
        chai_1.assert.isNumber(numValues, "Expected 'numValues' parameter to 'Series.head' function to be a number.");
        if (numValues === 0) {
            return new Series(); // Empty series.
        }
        var toTake = numValues < 0 ? this.count() - Math.abs(numValues) : numValues;
        return this.take(toTake);
    };
    /**
     * Get X values from the end of the series.
     * Pass in a negative value to get all items at the tail except X values at the head.
     *
     * @param numValues - Number of values to take.
     *
     * @returns Returns a new series that has only the specified number of values taken from the end of the input sequence.
     */
    Series.prototype.tail = function (numValues) {
        chai_1.assert.isNumber(numValues, "Expected 'numValues' parameter to 'Series.tail' function to be a number.");
        if (numValues === 0) {
            return new Series(); // Empty series.
        }
        var toSkip = numValues > 0 ? this.count() - numValues : Math.abs(numValues);
        return this.skip(toSkip);
    };
    /**
     * Filter a series by a predicate selector.
     *
     * @param predicate - Predicte function to filter rows of the series.
     *
     * @returns Returns a new series containing only the values that match the predicate.
     */
    Series.prototype.where = function (predicate) {
        var _this = this;
        chai_1.assert.isFunction(predicate, "Expected 'predicate' parameter to 'Series.where' function to be a function.");
        return new Series(function () { return ({
            values: new where_iterable_1.WhereIterable(_this.getContent().values, predicate),
            pairs: new where_iterable_1.WhereIterable(_this.getContent().pairs, function (pair) { return predicate(pair[1]); })
        }); });
    };
    /**
     * Invoke a callback function for each value in the series.
     *
     * @param callback - The calback to invoke for each value.
     *
     * @returns Returns the input series with no modifications.
     */
    Series.prototype.forEach = function (callback) {
        chai_1.assert.isFunction(callback, "Expected 'callback' parameter to 'Series.forEach' to be a function.");
        var index = 0;
        try {
            for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                var value = _b.value;
                callback(value, index++);
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_9) throw e_9.error; }
        }
        return this;
        var e_9, _c;
    };
    ;
    /**
     * Determine if the predicate returns truthy for all values in the series.
     * Returns false as soon as the predicate evaluates to falsy.
     * Returns true if the predicate returns truthy for all values in the series.
     * Returns false if the series is empty.
     *
     * @param predicate - Predicate function that receives each value in turn and returns truthy for a match, otherwise falsy.
     *
     * @returns {boolean} Returns true if the predicate has returned truthy for every value in the sequence, otherwise returns false.
     */
    Series.prototype.all = function (predicate) {
        chai_1.assert.isFunction(predicate, "Expected 'predicate' parameter to 'Series.all' to be a function.");
        var count = 0;
        try {
            for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                var value = _b.value;
                if (!predicate(value)) {
                    return false;
                }
                ++count;
            }
        }
        catch (e_10_1) { e_10 = { error: e_10_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_10) throw e_10.error; }
        }
        return count > 0;
        var e_10, _c;
    };
    /**
     * Determine if the predicate returns truthy for any of the values in the series.
     * Returns true as soon as the predicate returns truthy.
     * Returns false if the predicate never returns truthy.
     * If no predicate is specified the value itself is checked.
     *
     * @param [predicate] - Optional predicate function that receives each value in turn and returns truthy for a match, otherwise falsy.
     *
     * @returns Returns true if the predicate has returned truthy for any value in the sequence, otherwise returns false.
     */
    Series.prototype.any = function (predicate) {
        if (predicate) {
            chai_1.assert.isFunction(predicate, "Expected 'predicate' parameter to 'Series.any' to be a function.");
        }
        if (predicate) {
            try {
                // Use the predicate to check each value.
                for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var value = _b.value;
                    if (predicate(value)) {
                        return true;
                    }
                }
            }
            catch (e_11_1) { e_11 = { error: e_11_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_11) throw e_11.error; }
            }
        }
        else {
            try {
                // Check each value directly.
                for (var _d = __values(this), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var value = _e.value;
                    if (value) {
                        return true;
                    }
                }
            }
            catch (e_12_1) { e_12 = { error: e_12_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                }
                finally { if (e_12) throw e_12.error; }
            }
        }
        return false; // Nothing passed.
        var e_11, _c, e_12, _f;
    };
    /**
     * Determine if the predicate returns truthy for none of the values in the series.
     * Returns true for an empty series.
     * Returns true if the predicate always returns falsy.
     * Otherwise returns false.
     * If no predicate is specified the value itself is checked.
     *
     * @param [predicate] - Optional predicate function that receives each value in turn and returns truthy for a match, otherwise falsy.
     *
     * @returns Returns true if the predicate has returned truthy for no values in the series, otherwise returns false.
     */
    Series.prototype.none = function (predicate) {
        if (predicate) {
            chai_1.assert.isFunction(predicate, "Expected 'predicate' parameter to 'Series.none' to be a function.");
        }
        if (predicate) {
            try {
                // Use the predicate to check each value.
                for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var value = _b.value;
                    if (predicate(value)) {
                        return false;
                    }
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_13) throw e_13.error; }
            }
        }
        else {
            try {
                // Check each value directly.
                for (var _d = __values(this), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var value = _e.value;
                    if (value) {
                        return false;
                    }
                }
            }
            catch (e_14_1) { e_14 = { error: e_14_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                }
                finally { if (e_14) throw e_14.error; }
            }
        }
        return true; // Nothing failed the predicate.
        var e_13, _c, e_14, _f;
    };
    /**
     * Get a new series containing all values starting at and after the specified index value.
     *
     * @param indexValue - The index value to search for before starting the new series.
     *
     * @returns Returns a new series containing all values starting at and after the specified index value.
     */
    Series.prototype.startAt = function (indexValue) {
        var _this = this;
        return new Series(function () {
            var lessThan = _this.getIndex().getLessThan();
            return {
                index: new skip_while_iterable_1.SkipWhileIterable(_this.getContent().index, function (index) { return lessThan(index, indexValue); }),
                pairs: new skip_while_iterable_1.SkipWhileIterable(_this.getContent().pairs, function (pair) { return lessThan(pair[0], indexValue); }),
            };
        });
    };
    /**
     * Get a new series containing all values up until and including the specified index value (inclusive).
     *
     * @param indexValue - The index value to search for before ending the new series.
     *
     * @returns Returns a new series containing all values up until and including the specified index value.
     */
    Series.prototype.endAt = function (indexValue) {
        var _this = this;
        return new Series(function () {
            var lessThanOrEqualTo = _this.getIndex().getLessThanOrEqualTo();
            return {
                index: new take_while_iterable_1.TakeWhileIterable(_this.getContent().index, function (index) { return lessThanOrEqualTo(index, indexValue); }),
                pairs: new take_while_iterable_1.TakeWhileIterable(_this.getContent().pairs, function (pair) { return lessThanOrEqualTo(pair[0], indexValue); }),
            };
        });
    };
    /**
     * Get a new series containing all values up to the specified index value (exclusive).
     *
     * @param indexValue - The index value to search for before ending the new series.
     *
     * @returns Returns a new series containing all values up to the specified inde value.
     */
    Series.prototype.before = function (indexValue) {
        var _this = this;
        return new Series(function () {
            var lessThan = _this.getIndex().getLessThan();
            return {
                index: new take_while_iterable_1.TakeWhileIterable(_this.getContent().index, function (index) { return lessThan(index, indexValue); }),
                pairs: new take_while_iterable_1.TakeWhileIterable(_this.getContent().pairs, function (pair) { return lessThan(pair[0], indexValue); }),
            };
        });
    };
    /**
     * Get a new series containing all values after the specified index value (exclusive).
     *
     * @param indexValue - The index value to search for.
     *
     * @returns Returns a new series containing all values after the specified index value.
     */
    Series.prototype.after = function (indexValue) {
        var _this = this;
        return new Series(function () {
            var lessThanOrEqualTo = _this.getIndex().getLessThanOrEqualTo();
            return {
                index: new skip_while_iterable_1.SkipWhileIterable(_this.getContent().index, function (index) { return lessThanOrEqualTo(index, indexValue); }),
                pairs: new skip_while_iterable_1.SkipWhileIterable(_this.getContent().pairs, function (pair) { return lessThanOrEqualTo(pair[0], indexValue); }),
            };
        });
    };
    /**
     * Get a new series containing all values between the specified index values (inclusive).
     *
     * @param startIndexValue - The index where the new sequence starts.
     * @param endIndexValue - The index where the new sequence ends.
     *
     * @returns Returns a new series containing all values between the specified index values (inclusive).
     */
    Series.prototype.between = function (startIndexValue, endIndexValue) {
        return this.startAt(startIndexValue).endAt(endIndexValue);
    };
    /**
     * Format the series for display as a string.
     * This forces lazy evaluation to complete.
     *
     * @returns Generates and returns a string representation of the series or dataframe.
     */
    Series.prototype.toString = function () {
        var header = ["__index__", "__value__"];
        var rows = this.toPairs();
        var table = new Table();
        rows.forEach(function (row, rowIndex) {
            row.forEach(function (cell, cellIndex) {
                table.cell(header[cellIndex], cell);
            });
            table.newRow();
        });
        return table.toString();
    };
    ;
    //
    // Helper function to parse a string to an int.
    //
    Series.parseInt = function (value, valueIndex) {
        if (value === undefined) {
            return undefined;
        }
        else {
            chai_1.assert.isString(value, "Called Series.parseInts, expected all values in the series to be strings, instead found a '" + typeof (value) + "' at index " + valueIndex);
            if (value.length === 0) {
                return undefined;
            }
            return parseInt(value);
        }
    };
    /**
     * Parse a series with string values to a series with int values.
     *
     * @returns Returns a new series where string values from the original series have been parsed to integer values.
     */
    Series.prototype.parseInts = function () {
        return this.select(Series.parseInt);
    };
    ;
    //
    // Helper function to parse a string to a float.
    //
    Series.parseFloat = function (value, valueIndex) {
        if (value === undefined) {
            return undefined;
        }
        else {
            chai_1.assert.isString(value, "Called Series.parseFloats, expected all values in the series to be strings, instead found a '" + typeof (value) + "' at index " + valueIndex);
            if (value.length === 0) {
                return undefined;
            }
            return parseFloat(value);
        }
    };
    /**
     * Parse a series with string values to a series with float values.
     *
     * @returns Returns a new series where string values from the original series have been parsed to floating-point values.
     */
    Series.prototype.parseFloats = function () {
        return this.select(Series.parseFloat);
    };
    ;
    //
    // Helper function to parse a string to a date.
    //
    Series.parseDate = function (value, valueIndex, formatString) {
        if (value === undefined) {
            return undefined;
        }
        else {
            chai_1.assert.isString(value, "Called Series.parseDates, expected all values in the series to be strings, instead found a '" + typeof (value) + "' at index " + valueIndex);
            if (value.length === 0) {
                return undefined;
            }
            return moment(value, formatString).toDate();
        }
    };
    /**
     * Parse a series with string values to a series with date values.
     *
     * @param [formatString] Optional formatting string for dates.
     *
     * @returns Returns a new series where string values from the original series have been parsed to Date values.
     */
    Series.prototype.parseDates = function (formatString) {
        if (formatString) {
            chai_1.assert.isString(formatString, "Expected optional 'formatString' parameter to Series.parseDates to be a string (if specified).");
        }
        return this.select(function (value, valueIndex) { return Series.parseDate(value, valueIndex, formatString); });
    };
    //
    // Helper function to convert a value to a string.
    //
    Series.toString = function (value, formatString) {
        if (value === undefined) {
            return undefined;
        }
        else if (value === null) {
            return null;
        }
        else if (formatString && Sugar.Object.isDate(value)) {
            return moment(value).format(formatString);
        }
        else if (formatString && moment.isMoment(value)) {
            return value.format(formatString);
        }
        else if (formatString && Sugar.Object.isNumber(value)) {
            return numeral(value).format(formatString);
        }
        else {
            return value.toString();
        }
    };
    /**
     * Convert a series of values of different types to a series of string values.
     *
     * @param [formatString] Optional formatting string for numbers and dates.
     *
     * Numeral.js is used for number formatting.
     * http://numeraljs.com/
     *
     * Moment is used for date formatting.
     * https://momentjs.com/docs/#/parsing/string-format/
     *
     * @returns Returns a new series where the values from the original series have been stringified.
     */
    Series.prototype.toStrings = function (formatString) {
        if (formatString) {
            chai_1.assert.isString(formatString, "Expected optional 'formatString' parameter to Series.toStrings to be a string (if specified).");
        }
        return this.select(function (value) { return Series.toString(value, formatString); });
    };
    /**
     * Forces lazy evaluation to complete and 'bakes' the series into memory.
     *
     * @returns Returns a series that has been 'baked', all lazy evaluation has completed.
     */
    Series.prototype.bake = function () {
        if (this.getContent().isBaked) {
            // Already baked.
            return this;
        }
        return new Series({
            values: this.toArray(),
            pairs: this.toPairs(),
            baked: true,
        });
    };
    ;
    /**
     * Inflate the series to a dataframe.
     *
     * @param [selector] Optional selector function that transforms each value in the series to a row in the new dataframe.
     *
     * @returns Returns a new dataframe that has been created from the input series via the 'selector' function.
     */
    Series.prototype.inflate = function (selector) {
        if (selector) {
            chai_1.assert.isFunction(selector, "Expected 'selector' parameter to Series.inflate to be a selector function.");
            return new dataframe_1.DataFrame({
                values: new select_iterable_1.SelectIterable(this.getContent().values, selector),
                index: this.getContent().index,
                pairs: new select_iterable_1.SelectIterable(this.getContent().pairs, function (pair, index) { return [pair[0], selector(pair[1], index)]; }),
            });
        }
        else {
            return new dataframe_1.DataFrame({
                values: this.getContent().values,
                index: this.getContent().index,
                pairs: this.getContent().pairs
            });
        }
    };
    /**
     * Sum the values in a series.
     *
     * @returns Returns the sum of the number values in the series.
     */
    Series.prototype.sum = function () {
        if (this.none()) {
            return 0;
        }
        var numberSeries = this; // Have to assume we are working with a number series here.
        return numberSeries.aggregate(function (prev, value) { return prev + value; });
    };
    /**
     * Average the values in a series.
     *
     * @returns Returns the average of the number values in the series.
     */
    Series.prototype.average = function () {
        var count = this.count();
        if (count > 0) {
            return this.sum() / count;
        }
        else {
            return 0;
        }
    };
    /**
     * Get the median value in the series. Not this sorts the series, so can be expensive.
     *
     * @returns Returns the median of the values in the series.
     */
    Series.prototype.median = function () {
        //
        // From here: http://stackoverflow.com/questions/5275115/add-a-median-method-to-a-list
        //
        var numberSeries = this; // Have to assume we are working with a number series here.
        var count = numberSeries.count();
        if (count === 0) {
            return 0;
        }
        var ordered = numberSeries.orderBy(function (value) { return value; }).toArray();
        if ((count % 2) == 0) {
            // Even.
            var a = ordered[count / 2 - 1];
            var b = ordered[count / 2];
            return (a + b) / 2;
        }
        // Odd
        return ordered[Math.floor(count / 2)];
    };
    /**
     * Get the min value in the series.
     *
     * @returns Returns the minimum of the number values in the series.
     */
    Series.prototype.min = function () {
        var numberSeries = this; // Have to assume we are working with a number series here.
        return numberSeries.aggregate(function (prev, value) { return Math.min(prev, value); });
    };
    /**
     * Get the max value in the series.
     *
     * @returns Returns the maximum of the number values in the series.
     */
    Series.prototype.max = function () {
        var numberSeries = this; // Have to assume we are working with a number series here.
        return numberSeries.aggregate(function (prev, value) { return Math.max(prev, value); });
    };
    /**
     * Invert the sign of every number value in the series.
     * This assumes that the input series contains numbers.
     *
     * @returns Returns a new series with all number values inverted.
     */
    Series.prototype.invert = function () {
        var inputSeries = this;
        return inputSeries.select(function (value) { return -value; });
    };
    /**
     * Counts the number of sequential values where the predicate evaluates to truthy.
     * Outputs 0 values when the predicate evaluates to falsy.
     *
     * @param predicate User-defined function. Should evaluate to truthy to activate the counter or falsy to deactivate it.
     *
     * @returns Returns a new series that counts up the number of sequential values where the predicate evaluates to truthy. 0 values appear when the prediate evaluates to falsy.
     */
    Series.prototype.counter = function (predicate) {
        return this.groupSequentialBy(predicate)
            .selectMany(function (group, i) {
            if (predicate(group.first())) {
                // This group matches the predicate.
                return __1.range(1, group.count())
                    .withIndex(group.getIndex())
                    .toPairs(); //TODO: selectMany wipes the index. It needs to respect it!
            }
            else {
                // This group doesn't match the predicate.
                return __1.replicate(0, group.count())
                    .withIndex(group.getIndex())
                    .toPairs(); //TODO: selectMany wipes the index. It needs to respect it!
            }
        })
            .withIndex(function (pair) { return pair[0]; })
            .select(function (pair) { return pair[1]; });
    };
    /**
     * Reverse the series.
     *
     * @returns Returns a new series that is the reverse of the input.
     */
    Series.prototype.reverse = function () {
        var _this = this;
        return new Series(function () { return ({
            values: new reverse_iterable_1.ReverseIterable(_this.getContent().values),
            index: new reverse_iterable_1.ReverseIterable(_this.getContent().index),
            pairs: new reverse_iterable_1.ReverseIterable(_this.getContent().pairs)
        }); });
    };
    /**
     * Returns only values in the series that have distinct values.
     *
     * @param selector - Selects the value used to compare for duplicates.
     *
     * @returns Returns a series containing only unique values as determined by the 'selector' function.
     */
    Series.prototype.distinct = function (selector) {
        var _this = this;
        return new Series(function () { return ({
            values: new distinct_iterable_1.DistinctIterable(_this.getContent().values, selector),
            pairs: new distinct_iterable_1.DistinctIterable(_this.getContent().pairs, function (pair) { return selector && selector(pair[1]) || pair[1]; })
        }); });
    };
    /**
     * Group the series according to the selector.
     *
     * @param selector - Selector that defines the value to group by.
     *
     * @returns Returns a series of groups. Each group is a series with values that have been grouped by the 'selector' function.
     */
    Series.prototype.groupBy = function (selector) {
        var _this = this;
        chai_1.assert.isFunction(selector, "Expected 'selector' parameter to 'Series.groupBy' to be a selector function that determines the value to group the series by.");
        return new Series(function () {
            var groups = []; // Each group, in order of discovery.
            var groupMap = {}; // Group map, records groups by key.
            var valueIndex = 0;
            try {
                for (var _a = __values(_this.getContent().pairs), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var pair = _b.value;
                    var groupKey = selector(pair[1], valueIndex);
                    ++valueIndex;
                    var existingGroup = groupMap[groupKey];
                    if (existingGroup) {
                        existingGroup.push(pair);
                    }
                    else {
                        var newGroup = [];
                        newGroup.push(pair);
                        groups.push(newGroup);
                        groupMap[groupKey] = newGroup;
                    }
                }
            }
            catch (e_15_1) { e_15 = { error: e_15_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_15) throw e_15.error; }
            }
            return {
                values: groups.map(function (group) { return new Series({ pairs: group }); })
            };
            var e_15, _c;
        });
    };
    /**
     * Group sequential values into a Series of windows.
     *
     * @param selector - Optional selector that defines the value to group by.
     *
     * @returns Returns a series of groups. Each group is a series with values that have been grouped by the 'selector' function.
     */
    Series.prototype.groupSequentialBy = function (selector) {
        if (selector) {
            chai_1.assert.isFunction(selector, "Expected 'selector' parameter to 'Series.groupSequentialBy' to be a selector function that determines the value to group the series by.");
        }
        else {
            selector = function (value) { return value; };
        }
        return this.variableWindow(function (a, b) { return selector(a) === selector(b); });
    };
    /**
     * Concatenate multiple series into a single series.
     *
     * @param series - Array of series to concatenate.
     *
     * @returns Returns a single series concatenated from multiple input series.
     */
    Series.concat = function (series) {
        chai_1.assert.isArray(series, "Expected 'series' parameter to 'Series.concat' to be an array of series.");
        return new Series(function () {
            var upcast = series; // Upcast so that we can access private index, values and pairs.
            var contents = upcast.map(function (series) { return series.getContent(); });
            return {
                values: new concat_iterable_1.ConcatIterable(contents.map(function (content) { return content.values; })),
                pairs: new concat_iterable_1.ConcatIterable(contents.map(function (content) { return content.pairs; })),
            };
        });
    };
    /**
     * Concatenate multiple other series onto this series.
     *
     * @param series - Multiple arguments. Each can be either a series or an array of series.
     *
     * @returns Returns a single series concatenated from multiple input series.
     */
    Series.prototype.concat = function () {
        var series = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            series[_i] = arguments[_i];
        }
        var concatInput = [this];
        try {
            for (var series_1 = __values(series), series_1_1 = series_1.next(); !series_1_1.done; series_1_1 = series_1.next()) {
                var input = series_1_1.value;
                if (Sugar.Object.isArray(input)) {
                    try {
                        for (var input_1 = __values(input), input_1_1 = input_1.next(); !input_1_1.done; input_1_1 = input_1.next()) {
                            var subInput = input_1_1.value;
                            concatInput.push(subInput);
                        }
                    }
                    catch (e_16_1) { e_16 = { error: e_16_1 }; }
                    finally {
                        try {
                            if (input_1_1 && !input_1_1.done && (_a = input_1.return)) _a.call(input_1);
                        }
                        finally { if (e_16) throw e_16.error; }
                    }
                }
                else {
                    concatInput.push(input);
                }
            }
        }
        catch (e_17_1) { e_17 = { error: e_17_1 }; }
        finally {
            try {
                if (series_1_1 && !series_1_1.done && (_b = series_1.return)) _b.call(series_1);
            }
            finally { if (e_17) throw e_17.error; }
        }
        return Series.concat(concatInput);
        var e_17, _b, e_16, _a;
    };
    /**
    * Zip together multiple series to create a new series.
    * Preserves the index of the first series.
    *
    * @param series - Multiple arguments. Each can be either a series or an array of series.
    * @param zipper - Selector function that produces a new series based on the input series.
    *
    * @returns Returns a single series zipped from multiple input series.
    */
    Series.zip = function (series, zipper) {
        chai_1.assert.isArray(series, "Expected 'series' parameter to 'Series.zip' to be an array of series.");
        if (series.length === 0) {
            return new Series();
        }
        var firstSeries = series[0];
        if (firstSeries.none()) {
            return new Series();
        }
        return new Series(function () {
            var firstSeriesUpCast = firstSeries;
            var upcast = series; // Upcast so that we can access private index, values and pairs.
            return {
                index: firstSeriesUpCast.getContent().index,
                values: new zip_iterable_1.ZipIterable(upcast.map(function (s) { return s.getContent().values; }), zipper),
            };
        });
    };
    Series.prototype.zip = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var selector = args[args.length - 1];
        var input = [this].concat(args.slice(0, args.length - 1));
        return Series.zip(input, function (values) { return selector.apply(void 0, __spread(values)); });
    };
    /**
     * Sorts the series by a value defined by the selector (ascending).
     *
     * @param selector Selects the value to sort by.
     *
     * @returns Returns a new ordered series that has been sorted by the value returned by the selector.
     */
    Series.prototype.orderBy = function (selector) {
        //TODO: Should pass a config fn to OrderedSeries. Could just pass in 'this'. The getContent() wouldn't have to be evaluated here.
        return new OrderedSeries(this.getContent().values, this.getContent().pairs, selector, ordered_iterable_1.Direction.Ascending, null);
    };
    /**
     * Sorts the series by a value defined by the selector (descending).
     *
     * @param selector Selects the value to sort by.
     *
     * @returns Returns a new ordered series that has been sorted by the value returned by the selector.
     */
    Series.prototype.orderByDescending = function (selector) {
        //TODO: Should pass a config fn to OrderedSeries.
        return new OrderedSeries(this.getContent().values, this.getContent().pairs, selector, ordered_iterable_1.Direction.Descending, null);
    };
    /**
     * Returns the unique union of values between two series.
     *
     * @param other - The other series to combine.
     * @param [selector] - Optional function that selects the value to compare to detemrine distinctness.
     *
     * @returns Returns the union of two series.
     */
    Series.prototype.union = function (other, selector) {
        if (selector) {
            chai_1.assert.isFunction(selector, "Expected optional 'selector' parameter to 'Series.union' to be a selector function.");
        }
        return this.concat(other).distinct(selector);
    };
    ;
    /**
     * Returns the intersection of values between two series.
     *
     * @param inner - The other series to combine.
     * @param [outerSelector] - Optional function to select the key for matching the two series.
     * @param [innerSelector] - Optional function to select the key for matching the two series.
     *
     * @returns Returns the intersection of two series.
     */
    Series.prototype.intersection = function (inner, outerSelector, innerSelector) {
        if (outerSelector) {
            chai_1.assert.isFunction(outerSelector, "Expected optional 'outerSelector' parameter to 'Series.intersection' to be a function.");
        }
        else {
            outerSelector = function (value) { return value; };
        }
        if (innerSelector) {
            chai_1.assert.isFunction(innerSelector, "Expected optional 'innerSelector' parameter to 'Series.intersection' to be a function.");
        }
        else {
            innerSelector = function (value) { return value; };
        }
        var outer = this;
        return outer.where(function (outerValue) {
            var outerKey = outerSelector(outerValue);
            return inner
                .where(function (innerValue) { return outerKey === innerSelector(innerValue); })
                .any();
        });
    };
    ;
    /**
     * Returns the exception of values between two series.
     *
     * @param inner - The other series to combine.
     * @param [outerSelector] - Optional function to select the key for matching the two series.
     * @param [innerSelector] - Optional function to select the key for matching the two series.
     *
     * @returns Returns the difference between the two series.
     */
    Series.prototype.except = function (inner, outerSelector, innerSelector) {
        if (outerSelector) {
            chai_1.assert.isFunction(outerSelector, "Expected optional 'outerSelector' parameter to 'Series.except' to be a function.");
        }
        else {
            outerSelector = function (value) { return value; };
        }
        if (innerSelector) {
            chai_1.assert.isFunction(innerSelector, "Expected optional 'innerSelector' parameter to 'Series.except' to be a function.");
        }
        else {
            innerSelector = function (value) { return value; };
        }
        var outer = this;
        return outer.where(function (outerValue) {
            var outerKey = outerSelector(outerValue);
            return inner
                .where(function (innerValue) { return outerKey === innerSelector(innerValue); })
                .none();
        });
    };
    ;
    /**
      * Correlates the elements of two series on matching keys.
      *
      * @param this - The outer series to join.
      * @param inner - The inner series to join.
      * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
      * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
      * @param resultSelector - Selector that defines how to merge outer and inner values.
      *
      * @returns Returns the joined series.
      */
    Series.prototype.join = function (inner, outerKeySelector, innerKeySelector, resultSelector) {
        chai_1.assert.isFunction(outerKeySelector, "Expected 'outerKeySelector' parameter of 'Series.join' to be a selector function.");
        chai_1.assert.isFunction(innerKeySelector, "Expected 'innerKeySelector' parameter of 'Series.join' to be a selector function.");
        chai_1.assert.isFunction(resultSelector, "Expected 'resultSelector' parameter of 'Series.join' to be a selector function.");
        var outer = this;
        return new Series(function () {
            var innerMap = inner
                .groupBy(innerKeySelector)
                .toObject(function (group) { return innerKeySelector(group.first()); }, function (group) { return group; });
            var outerContent = outer.getContent();
            var output = [];
            try {
                for (var outer_1 = __values(outer), outer_1_1 = outer_1.next(); !outer_1_1.done; outer_1_1 = outer_1.next()) {
                    var outerValue = outer_1_1.value;
                    var outerKey = outerKeySelector(outerValue);
                    var innerGroup = innerMap[outerKey];
                    if (innerGroup) {
                        try {
                            for (var innerGroup_1 = __values(innerGroup), innerGroup_1_1 = innerGroup_1.next(); !innerGroup_1_1.done; innerGroup_1_1 = innerGroup_1.next()) {
                                var innerValue = innerGroup_1_1.value;
                                output.push(resultSelector(outerValue, innerValue));
                            }
                        }
                        catch (e_18_1) { e_18 = { error: e_18_1 }; }
                        finally {
                            try {
                                if (innerGroup_1_1 && !innerGroup_1_1.done && (_a = innerGroup_1.return)) _a.call(innerGroup_1);
                            }
                            finally { if (e_18) throw e_18.error; }
                        }
                    }
                }
            }
            catch (e_19_1) { e_19 = { error: e_19_1 }; }
            finally {
                try {
                    if (outer_1_1 && !outer_1_1.done && (_b = outer_1.return)) _b.call(outer_1);
                }
                finally { if (e_19) throw e_19.error; }
            }
            return {
                values: output
            };
            var e_19, _b, e_18, _a;
        });
    };
    /**
     * Performs an outer join on two series. Correlates the elements based on matching keys.
     * Includes elements from both series that have no correlation in the other series.
     *
     * @param this - The outer series to join.
     * @param inner - The inner series to join.
     * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
     * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
     * @param resultSelector - Selector that defines how to merge outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @returns Returns the joined series.
     */
    Series.prototype.joinOuter = function (inner, outerKeySelector, innerKeySelector, resultSelector) {
        chai_1.assert.isFunction(outerKeySelector, "Expected 'outerKeySelector' parameter of 'Series.joinOuter' to be a selector function.");
        chai_1.assert.isFunction(innerKeySelector, "Expected 'innerKeySelector' parameter of 'Series.joinOuter' to be a selector function.");
        chai_1.assert.isFunction(resultSelector, "Expected 'resultSelector' parameter of 'Series.joinOuter' to be a selector function.");
        // Get the results in the outer that are not in the inner.
        var outer = this;
        var outerResult = outer.except(inner, outerKeySelector, innerKeySelector)
            .select(function (outer) { return resultSelector(outer, null); })
            .resetIndex();
        // Get the results in the inner that are not in the outer.
        var innerResult = inner.except(outer, innerKeySelector, outerKeySelector)
            .select(function (inner) { return resultSelector(null, inner); })
            .resetIndex();
        // Get the intersection of results between inner and outer.
        var intersectionResults = outer.join(inner, outerKeySelector, innerKeySelector, resultSelector);
        return outerResult
            .concat(intersectionResults)
            .concat(innerResult)
            .resetIndex();
    };
    ;
    /**
     * Performs a left outer join on two series. Correlates the elements based on matching keys.
     * Includes left elements that have no correlation.
     *
     * @param this - The outer series to join.
     * @param inner - The inner series to join.
     * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
     * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
     * @param resultSelector - Selector that defines how to merge outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @returns Returns the joined series.
     */
    Series.prototype.joinOuterLeft = function (inner, outerKeySelector, innerKeySelector, resultSelector) {
        chai_1.assert.isFunction(outerKeySelector, "Expected 'outerKeySelector' parameter of 'Series.joinOuterLeft' to be a selector function.");
        chai_1.assert.isFunction(innerKeySelector, "Expected 'innerKeySelector' parameter of 'Series.joinOuterLeft' to be a selector function.");
        chai_1.assert.isFunction(resultSelector, "Expected 'resultSelector' parameter of 'Series.joinOuterLeft' to be a selector function.");
        // Get the results in the outer that are not in the inner.
        var outer = this;
        var outerResult = outer.except(inner, outerKeySelector, innerKeySelector)
            .select(function (outer) { return resultSelector(outer, null); })
            .resetIndex();
        // Get the intersection of results between inner and outer.
        var intersectionResults = outer.join(inner, outerKeySelector, innerKeySelector, resultSelector);
        return outerResult
            .concat(intersectionResults)
            .resetIndex();
    };
    ;
    /**
     * Performs a right outer join on two series. Correlates the elements based on matching keys.
     * Includes right elements that have no correlation.
     *
     * @param this - The outer series to join.
     * @param inner - The inner series to join.
     * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
     * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
     * @param resultSelector - Selector that defines how to merge outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @returns Returns the joined series.
     */
    Series.prototype.joinOuterRight = function (inner, outerKeySelector, innerKeySelector, resultSelector) {
        chai_1.assert.isFunction(outerKeySelector, "Expected 'outerKeySelector' parameter of 'Series.joinOuterRight' to be a selector function.");
        chai_1.assert.isFunction(innerKeySelector, "Expected 'innerKeySelector' parameter of 'Series.joinOuterRight' to be a selector function.");
        chai_1.assert.isFunction(resultSelector, "Expected 'resultSelector' parameter of 'Series.joinOuterRight' to be a selector function.");
        // Get the results in the inner that are not in the outer.
        var outer = this;
        var innerResult = inner.except(outer, innerKeySelector, outerKeySelector)
            .select(function (inner) { return resultSelector(null, inner); })
            .resetIndex();
        // Get the intersection of results between inner and outer.
        var intersectionResults = outer.join(inner, outerKeySelector, innerKeySelector, resultSelector);
        return intersectionResults
            .concat(innerResult)
            .resetIndex();
    };
    /**
     * Produces a new series with all string values truncated to the requested maximum length.
     *
     * @param maxLength - The maximum length of the string values after truncation.
     *
     * @returns Returns a new series with strings that are truncated to the specified maximum length.
     */
    Series.prototype.truncateStrings = function (maxLength) {
        chai_1.assert.isNumber(maxLength, "Expected 'maxLength' parameter to 'Series.truncateStrings' to be a number.");
        return this.select(function (value) {
            if (Sugar.Object.isString(value)) {
                if (value.length > maxLength) {
                    return value.substring(0, maxLength);
                }
            }
            return value;
        });
    };
    ;
    /**
     * Insert a pair at the start of the series.
     *
     * @param pair - The pair to insert.
     *
     * @returns Returns a new series with the specified pair inserted.
     */
    Series.prototype.insertPair = function (pair) {
        chai_1.assert.isArray(pair, "Expected 'pair' parameter to 'Series.insertPair' to be an array.");
        chai_1.assert(pair.length === 2, "Expected 'pair' parameter to 'Series.insertPair' to be an array with two elements. The first element is the index, the second is the value.");
        return (new Series({ pairs: [pair] })).concat(this);
    };
    /**
     * Append a pair to the end of a Series.
     *
     * @param pair - The pair to append.
     *
     * @returns Returns a new series with the specified pair appended.
     */
    Series.prototype.appendPair = function (pair) {
        chai_1.assert.isArray(pair, "Expected 'pair' parameter to 'Series.appendPair' to be an array.");
        chai_1.assert(pair.length === 2, "Expected 'pair' parameter to 'Series.appendPair' to be an array with two elements. The first element is the index, the second is the value.");
        return this.concat(new Series({ pairs: [pair] }));
    };
    /**
     * Fill gaps in a series.
     *
     * @param comparer - Comparer that is passed pairA and pairB, two consecutive rows, return truthy if there is a gap between the rows, or falsey if there is no gap.
     * @param generator - Generator that is passed pairA and pairB, two consecutive rows, returns an array of pairs that fills the gap between the rows.
     *
     * @returns Returns a new series with gaps filled in.
     */
    Series.prototype.fillGaps = function (comparer, generator) {
        chai_1.assert.isFunction(comparer, "Expected 'comparer' parameter to 'Series.fillGaps' to be a comparer function that compares two values and returns a boolean.");
        chai_1.assert.isFunction(generator, "Expected 'generator' parameter to 'Series.fillGaps' to be a generator function that takes two values and returns an array of generated pairs to span the gap.");
        return this.rollingWindow(2)
            .selectMany(function (window) {
            var pairs = window.toPairs();
            var pairA = pairs[0];
            var pairB = pairs[1];
            if (!comparer(pairA, pairB)) {
                return [pairA];
            }
            var generatedRows = generator(pairA, pairB);
            chai_1.assert.isArray(generatedRows, "Expected return from 'generator' parameter to 'Series.fillGaps' to be an array of pairs, instead got a " + typeof (generatedRows));
            return [pairA].concat(generatedRows);
        })
            .withIndex(function (pair) { return pair[0]; })
            .select(function (pair) { return pair[1]; })
            .concat(this.tail(1));
    };
    /**
     * Returns the specified default sequence if the series is empty.
     *
     * @param defaultSequence - Default sequence to return if the series is empty.
     *
     * @returns Returns 'defaultSequence' if the series is empty.
     */
    Series.prototype.defaultIfEmpty = function (defaultSequence) {
        if (this.none()) {
            if (defaultSequence instanceof Series) {
                return defaultSequence;
            }
            else if (Sugar.Object.isArray(defaultSequence)) {
                return new Series(defaultSequence);
            }
            else {
                throw new Error("Expected 'defaultSequence' parameter to 'Series.defaultIfEmpty' to be an array or a series.");
            }
        }
        else {
            return this;
        }
    };
    /**
     * Detect the types of the values in the sequence.
     *
     * @returns Returns a dataframe that describes the data types contained in the input series or dataframe.
     */
    Series.prototype.detectTypes = function () {
        var _this = this;
        return new dataframe_1.DataFrame(function () {
            var values = _this.toArray();
            var totalValues = values.length;
            var typeFrequencies = _this.select(function (value) {
                var valueType = typeof (value);
                if (valueType === "object") {
                    if (Sugar.Object.isDate(value)) {
                        valueType = "date";
                    }
                }
                return valueType;
            })
                .aggregate({}, function (accumulated, valueType) {
                var typeInfo = accumulated[valueType];
                if (!typeInfo) {
                    typeInfo = {
                        count: 0
                    };
                    accumulated[valueType] = typeInfo;
                }
                ++typeInfo.count;
                return accumulated;
            });
            return {
                columnNames: ["Type", "Frequency"],
                rows: Object.keys(typeFrequencies)
                    .map(function (valueType) {
                    return [
                        valueType,
                        (typeFrequencies[valueType].count / totalValues) * 100
                    ];
                })
            };
        });
    };
    /**
     * Detect the frequency of values in the sequence.
     *
     * @returns Returns a dataframe that describes the values contained in the input sequence.
     */
    Series.prototype.detectValues = function () {
        var _this = this;
        return new dataframe_1.DataFrame(function () {
            var values = _this.toArray();
            var totalValues = values.length;
            var valueFrequencies = _this.aggregate({}, function (accumulated, value) {
                var valueKey = (value !== null && value.toString() || "null") + "-" + typeof (value);
                var valueInfo = accumulated[valueKey];
                if (!valueInfo) {
                    valueInfo = {
                        count: 0,
                        value: value,
                    };
                    accumulated[valueKey] = valueInfo;
                }
                ++valueInfo.count;
                return accumulated;
            });
            return {
                columnNames: ["Value", "Frequency"],
                rows: Object.keys(valueFrequencies)
                    .map(function (valueKey) {
                    var valueInfo = valueFrequencies[valueKey];
                    return [
                        valueInfo.value,
                        (valueInfo.count / totalValues) * 100
                    ];
                })
            };
        });
    };
    Series.defaultCountIterable = new count_iterable_1.CountIterable();
    Series.defaultEmptyIterable = new empty_iterable_1.EmptyIterable();
    return Series;
}());
exports.Series = Series;
/**
 * @hidden
 * A series that has been ordered.
 */
var OrderedSeries = /** @class */ (function (_super) {
    __extends(OrderedSeries, _super);
    function OrderedSeries(values, pairs, selector, direction, parent) {
        var _this = this;
        var valueSortSpecs = [];
        var pairSortSpecs = [];
        var sortLevel = 0;
        while (parent !== null) {
            valueSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, parent.selector, parent.direction));
            pairSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, OrderedSeries.makePairsSelector(parent.selector), parent.direction));
            ++sortLevel;
            parent = parent.parent;
        }
        valueSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, selector, direction));
        pairSortSpecs.push(OrderedSeries.makeSortSpec(sortLevel, OrderedSeries.makePairsSelector(selector), direction));
        _this = _super.call(this, {
            values: new ordered_iterable_1.OrderedIterable(values, valueSortSpecs),
            pairs: new ordered_iterable_1.OrderedIterable(pairs, pairSortSpecs)
        }) || this;
        _this.parent = parent;
        _this.selector = selector;
        _this.direction = direction;
        _this.origValues = values;
        _this.origPairs = pairs;
        return _this;
    }
    //
    // Helper function to create a sort spec.
    //
    OrderedSeries.makeSortSpec = function (sortLevel, selector, direction) {
        return { sortLevel: sortLevel, selector: selector, direction: direction };
    };
    //
    // Helper function to make a sort selector for pairs, this captures the parent correct when generating the closure.
    //
    OrderedSeries.makePairsSelector = function (selector) {
        return function (pair, index) { return selector(pair[1], index); };
    };
    /**
     * Performs additional sorting (ascending).
     *
     * @param selector Selects the value to sort by.
     *
     * @returns Returns a new series has been additionally sorted by the value returned by the selector.
     */
    OrderedSeries.prototype.thenBy = function (selector) {
        //TODO: Should pass a config fn to OrderedSeries.
        return new OrderedSeries(this.origValues, this.origPairs, selector, ordered_iterable_1.Direction.Ascending, this);
    };
    /**
     * Performs additional sorting (descending).
     *
     * @param selector Selects the value to sort by.
     *
     * @returns Returns a new series has been additionally sorted by the value returned by the selector.
     */
    OrderedSeries.prototype.thenByDescending = function (selector) {
        //TODO: Should pass a config fn to OrderedSeries.
        return new OrderedSeries(this.origValues, this.origPairs, selector, ordered_iterable_1.Direction.Descending, this);
    };
    return OrderedSeries;
}(Series));
//# sourceMappingURL=series.js.map