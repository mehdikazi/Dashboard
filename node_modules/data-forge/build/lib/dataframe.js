"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var empty_iterable_1 = require("./iterables/empty-iterable");
var count_iterable_1 = require("./iterables/count-iterable");
var multi_iterable_1 = require("./iterables/multi-iterable");
var select_iterable_1 = require("./iterables/select-iterable");
var select_many_iterable_1 = require("./iterables/select-many-iterable");
var take_iterable_1 = require("./iterables/take-iterable");
var take_while_iterable_1 = require("./iterables/take-while-iterable");
var where_iterable_1 = require("./iterables/where-iterable");
var concat_iterable_1 = require("./iterables/concat-iterable");
var dataframe_window_iterable_1 = require("./iterables/dataframe-window-iterable");
var reverse_iterable_1 = require("./iterables/reverse-iterable");
var zip_iterable_1 = require("./iterables/zip-iterable");
var csv_rows_iterable_1 = require("./iterables/csv-rows-iterable");
var distinct_iterable_1 = require("./iterables/distinct-iterable");
var dataframe_rolling_window_iterable_1 = require("./iterables/dataframe-rolling-window-iterable");
var dataframe_variable_window_iterable_1 = require("./iterables/dataframe-variable-window-iterable");
var ordered_iterable_1 = require("./iterables/ordered-iterable");
var Sugar = require("sugar");
var index_1 = require("./index");
var extract_element_iterable_1 = require("./iterables/extract-element-iterable");
var skip_iterable_1 = require("./iterables/skip-iterable");
var skip_while_iterable_1 = require("./iterables/skip-while-iterable");
var Table = require('easy-table');
var chai_1 = require("chai");
var moment = require("moment");
var series_1 = require("./series");
var column_names_iterable_1 = require("./iterables/column-names-iterable");
var utils_1 = require("./utils");
var PapaParse = require('papaparse');
;
/**
 * Class that represents a dataframe.
 * A dataframe contains an indexed sequence of data records.
 * Think of it as a spreadsheet or CSV file in memory.
 *
 * Each data record contains multiple named fields, the value of each field represents one row in a column of data.
 * Each column of data is a named {@link Series}.
 * You think of a dataframe a collection of named data series.
 *
 * @typeparam IndexT The type to use for the index.
 * @typeparam ValueT The type to use for each row/data record.
 */
var DataFrame = /** @class */ (function () {
    /**
     * Create a dataframe.
     *
     * @param config This can be an array, a configuration object or a function that lazily produces a configuration object.
     *
     * It can be an array that specifies the data records that the dataframe contains.
     *
     * It can be a {@link IDataFrameConfig} that defines the data and configuration of the dataframe.
     *
     * Or it can be a function that lazily produces a {@link IDataFrameConfig}.
     *
     * @example
     * const df = new DataFrame();
     * @example
     * const df = new DataFrame([10, 20, 30, 40]);
     * @example
     * const df = new DataFrame({ index: [1, 2, 3, 4], values: [10, 20, 30, 40]});
     * @example
     * <br/>
     * <pre>
     * const lazyInit = () => ({ index: [1, 2, 3, 4], values: [10, 20, 30, 40] });
     * const df = new DataFrame(lazyInit);
     * </pre>
     */
    function DataFrame(config) {
        //
        // Function to lazy evaluate the configuration of the dataframe.
        //
        this.configFn = null;
        //
        // The content of the dataframe.
        // When this is null it means the dataframe is yet to be lazy initialised.
        //
        this.content = null;
        if (config) {
            if (Sugar.Object.isFunction(config)) {
                this.configFn = config;
            }
            else if (Sugar.Object.isArray(config) ||
                Sugar.Object.isFunction(config[Symbol.iterator])) {
                this.content = DataFrame.initFromArray(config);
            }
            else {
                this.content = DataFrame.initFromConfig(config);
            }
        }
        else {
            this.content = DataFrame.initEmpty();
        }
    }
    //
    // Initialise dataframe content from an iterable of values.
    //
    DataFrame.initFromArray = function (arr) {
        var firstResult = arr[Symbol.iterator]().next();
        var columnNames = !firstResult.done ? Object.keys(firstResult.value) : [];
        return {
            index: DataFrame.defaultCountIterable,
            values: arr,
            pairs: new multi_iterable_1.MultiIterable([DataFrame.defaultCountIterable, arr]),
            isBaked: true,
            columnNames: columnNames,
        };
    };
    //
    // Initialise an empty dataframe.
    //
    DataFrame.initEmpty = function () {
        return {
            index: DataFrame.defaultEmptyIterable,
            values: DataFrame.defaultEmptyIterable,
            pairs: DataFrame.defaultEmptyIterable,
            isBaked: true,
            columnNames: [],
        };
    };
    //
    // Initialise dataframe column names.
    //
    DataFrame.initColumnNames = function (inputColumnNames) {
        var outputColumnNames = [];
        var columnNamesMap = {};
        try {
            // Search for duplicate column names.
            for (var inputColumnNames_1 = __values(inputColumnNames), inputColumnNames_1_1 = inputColumnNames_1.next(); !inputColumnNames_1_1.done; inputColumnNames_1_1 = inputColumnNames_1.next()) {
                var columnName = inputColumnNames_1_1.value;
                var columnNameLwr = columnName.toLowerCase();
                if (columnNamesMap[columnNameLwr] === undefined) {
                    columnNamesMap[columnNameLwr] = 1;
                }
                else {
                    columnNamesMap[columnNameLwr] += 1;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (inputColumnNames_1_1 && !inputColumnNames_1_1.done && (_a = inputColumnNames_1.return)) _a.call(inputColumnNames_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var columnNoMap = {};
        try {
            for (var inputColumnNames_2 = __values(inputColumnNames), inputColumnNames_2_1 = inputColumnNames_2.next(); !inputColumnNames_2_1.done; inputColumnNames_2_1 = inputColumnNames_2.next()) {
                var columnName = inputColumnNames_2_1.value;
                var columnNameLwr = columnName.toLowerCase();
                if (columnNamesMap[columnNameLwr] > 1) {
                    var curColumnNo = 1;
                    // There are duplicates of this column.
                    if (columnNoMap[columnNameLwr] !== undefined) {
                        curColumnNo = columnNoMap[columnNameLwr];
                    }
                    outputColumnNames.push(columnName + "." + curColumnNo);
                    columnNoMap[columnNameLwr] = curColumnNo + 1;
                }
                else {
                    // No duplicates.
                    outputColumnNames.push(columnName);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (inputColumnNames_2_1 && !inputColumnNames_2_1.done && (_b = inputColumnNames_2.return)) _b.call(inputColumnNames_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return outputColumnNames;
        var e_1, _a, e_2, _b;
    };
    //
    // Check that a value is an interable.
    //
    DataFrame.checkIterable = function (input, fieldName) {
        if (Sugar.Object.isArray(input)) {
            // Ok
        }
        else if (Sugar.Object.isFunction(input[Symbol.iterator])) {
            // Assume it's an iterable.
            // Ok
        }
        else {
            // Not ok
            throw new Error("Expected '" + fieldName + "' field of DataFrame config object to be an array of values or an iterable of values.");
        }
    };
    ;
    //
    // Initialise dataframe content from a config object.
    //
    DataFrame.initFromConfig = function (config) {
        var index;
        var values;
        var pairs;
        var isBaked = false;
        var columnNames;
        if (config.pairs) {
            DataFrame.checkIterable(config.pairs, "pairs");
            pairs = config.pairs;
        }
        if (config.columns) {
            var columnsConfig = config.columns;
            if (Sugar.Object.isArray(columnsConfig) ||
                Sugar.Object.isFunction(columnsConfig[Symbol.iterator])) {
                var iterableColumnsConfig = columnsConfig;
                columnNames = Array.from(iterableColumnsConfig).map(function (column) { return column.name; });
                columnsConfig = utils_1.toMap(iterableColumnsConfig, function (column) { return column.name; }, function (column) { return column.series; });
            }
            else {
                chai_1.assert.isObject(columnsConfig, "Expected 'columns' member of 'config' parameter to DataFrame constructor to be an object with fields that define columns.");
                columnNames = Object.keys(columnsConfig);
            }
            var columnIterables = [];
            try {
                for (var columnNames_1 = __values(columnNames), columnNames_1_1 = columnNames_1.next(); !columnNames_1_1.done; columnNames_1_1 = columnNames_1.next()) {
                    var columnName = columnNames_1_1.value;
                    DataFrame.checkIterable(columnsConfig[columnName], columnName);
                    columnIterables.push(columnsConfig[columnName]);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (columnNames_1_1 && !columnNames_1_1.done && (_a = columnNames_1.return)) _a.call(columnNames_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            values = new csv_rows_iterable_1.CsvRowsIterable(columnNames, new multi_iterable_1.MultiIterable(columnIterables));
        }
        else {
            if (config.columnNames) {
                columnNames = this.initColumnNames(config.columnNames);
            }
            if (config.rows) {
                if (!config.columnNames) {
                    columnNames = new select_iterable_1.SelectIterable(new count_iterable_1.CountIterable(), function (c) { return "Column." + c.toString(); });
                }
                DataFrame.checkIterable(config.rows, 'rows');
                values = new csv_rows_iterable_1.CsvRowsIterable(columnNames, config.rows); // Convert data from rows to columns.
            }
            else if (config.values) {
                DataFrame.checkIterable(config.values, 'values');
                values = config.values;
                if (!config.columnNames) {
                    columnNames = new column_names_iterable_1.ColumnNamesIterable(values, config.considerAllRows || false);
                }
            }
            else if (pairs) {
                values = new extract_element_iterable_1.ExtractElementIterable(pairs, 1);
                if (!config.columnNames) {
                    columnNames = new column_names_iterable_1.ColumnNamesIterable(values, config.considerAllRows || false);
                }
            }
            else {
                values = DataFrame.defaultEmptyIterable;
                if (!config.columnNames) {
                    columnNames = DataFrame.defaultEmptyIterable;
                }
            }
        }
        if (config.index) {
            DataFrame.checkIterable(config.index, 'index');
            index = config.index;
        }
        else if (pairs) {
            index = new extract_element_iterable_1.ExtractElementIterable(pairs, 0);
        }
        else {
            index = DataFrame.defaultCountIterable;
        }
        if (!pairs) {
            pairs = new multi_iterable_1.MultiIterable([index, values]);
        }
        if (config.baked !== undefined) {
            isBaked = config.baked;
        }
        return {
            index: index,
            values: values,
            pairs: pairs,
            isBaked: isBaked,
            columnNames: columnNames,
        };
        var e_3, _a;
    };
    //
    // Ensure the dataframe content has been initialised.
    //
    DataFrame.prototype.lazyInit = function () {
        if (this.content === null && this.configFn !== null) {
            this.content = DataFrame.initFromConfig(this.configFn());
        }
    };
    //
    // Ensure the dataframe content is lazy initalised and return it.
    //
    DataFrame.prototype.getContent = function () {
        this.lazyInit();
        return this.content;
    };
    /**
     * Get an iterator to enumerate the values of the dataframe.
     * Enumerating the iterator forces lazy evaluation to complete.
     * This function is automatically called by `for...of`.
     *
     * @returns An iterator for the dataframe.
     *
     * @example
     * <br/>
     * <pre>
     * for (const row of df) {
     *     // ... do something with the row ...
     * }
     * </pre>
     */
    DataFrame.prototype[Symbol.iterator] = function () {
        return this.getContent().values[Symbol.iterator]();
    };
    /**
     * Get the names of the columns in the dataframe.
     *
     * @returns Returns an array of the column names in the dataframe.
     *
     * @example
     * console.log(df.getColumnNames());
     */
    DataFrame.prototype.getColumnNames = function () {
        return Array.from(this.getContent().columnNames);
    };
    /**
     * Retreive a collection of all columns in the dataframe.
     *
     * @returns Returns a series the columns in the dataframe.
     */
    DataFrame.prototype.getColumns = function () {
        var _this = this;
        return new series_1.Series(function () {
            var columnNames = _this.getColumnNames();
            return {
                values: columnNames.map(function (columnName) {
                    var series = _this.getSeries(columnName);
                    return {
                        name: columnName,
                        type: utils_1.determineType(series.first()),
                        series: series,
                    };
                }),
            };
        });
    };
    /**
     * Cast the value of the dataframe to a new type.
     * This operation has no effect but to retype the value that the dataframe contains.
     */
    DataFrame.prototype.cast = function () {
        return this;
    };
    /**
     * Get the index for the dataframe.
     */
    DataFrame.prototype.getIndex = function () {
        var _this = this;
        return new index_1.Index(function () { return ({ values: _this.getContent().index }); });
    };
    /**
     * Set a named column as the index of the data-frame.
     *
     * @param columnName - Name or index of the column to set as the index.
     *
     * @returns Returns a new dataframe with the values of a particular named column as the index.
     */
    DataFrame.prototype.setIndex = function (columnName) {
        chai_1.assert.isString(columnName, "Expected 'columnName' parameter to 'DataFrame.setIndex' to be a string that specifies the name of the column to set as the index for the dataframe.");
        return this.withIndex(this.getSeries(columnName));
    };
    /**
     * Apply a new index to the dataframe.
     *
     * @param newIndex The new array or iterable to apply to the dataframe. Can also be a selector to choose the index for each row in the dataframe.
     *
     * @returns Returns a new dataframe or dataframe with the specified index attached.
     */
    DataFrame.prototype.withIndex = function (newIndex) {
        var _this = this;
        if (Sugar.Object.isFunction(newIndex)) {
            return new DataFrame(function () {
                var content = _this.getContent();
                return {
                    columnNames: content.columnNames,
                    values: content.values,
                    index: _this.deflate(newIndex),
                };
            });
        }
        else {
            DataFrame.checkIterable(newIndex, 'newIndex');
            return new DataFrame(function () {
                var content = _this.getContent();
                return {
                    columnNames: content.columnNames,
                    values: content.values,
                    index: newIndex,
                };
            });
        }
    };
    /**
     * Resets the index of the dataframe back to the default zero-based sequential integer index.
     *
     * @returns Returns a new dataframe with the index reset to the default zero-based index.
     */
    DataFrame.prototype.resetIndex = function () {
        var _this = this;
        return new DataFrame(function () {
            var content = _this.getContent();
            return {
                columnNames: content.columnNames,
                values: content.values,
            };
        });
    };
    /**
     * Retreive a series from a column of the dataframe.
     *
     * @param columnName Specifies the name of the column that contains the series to retreive.
     */
    DataFrame.prototype.getSeries = function (columnName) {
        var _this = this;
        chai_1.assert.isString(columnName, "Expected 'columnName' parameter to 'DataFrame.getSeries' function to be a string that specifies the name of the column to retreive.");
        return new series_1.Series(function () { return ({
            values: new select_iterable_1.SelectIterable(_this.getContent().values, function (row) { return row[columnName]; }),
            index: _this.getContent().index,
        }); });
    };
    /**
 * Returns true if the column with the requested name exists in the dataframe.
 *
 * @param columnName - Name of the column to check.
 */
    DataFrame.prototype.hasSeries = function (columnName) {
        var columnNameLwr = columnName.toLowerCase();
        try {
            for (var _a = __values(this.getColumnNames()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var existingColumnName = _b.value;
                if (existingColumnName.toLowerCase() === columnNameLwr) {
                    return true;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return false;
        var e_4, _c;
    };
    /**
     *
     * Verify the existance of a column and return it.
     * Throws an exception if the column doesn't exist.
     *
     * @param columnName - Name or index of the column to retreive.
     */
    DataFrame.prototype.expectSeries = function (columnName) {
        if (!this.hasSeries(columnName)) {
            throw new Error("Expected dataframe to contain series with column name: '" + columnName + "'.");
        }
        return this.getSeries(columnName);
    };
    /**
     * Create a new dataframe with an additional column specified by the passed-in series.
     *
     * @param columnNameOrSpec - The name of the column to add or replace.
     * @param [series] - When columnNameOrSpec is a string that identifies the column to add, this specifies the Series to add to the data-frame or a function that produces a series (given a dataframe).
     *
     * @returns Returns a new dataframe replacing or adding a particular named column.
     */
    DataFrame.prototype.withSeries = function (columnNameOrSpec, series) {
        var _this = this;
        if (!Sugar.Object.isObject(columnNameOrSpec)) {
            chai_1.assert.isString(columnNameOrSpec, "Expected 'columnNameOrSpec' parameter to 'DataFrame.withSeries' function to be a string that specifies the column to set or replace.");
            if (!Sugar.Object.isFunction(series)) {
                chai_1.assert.isObject(series, "Expected 'series' parameter to 'DataFrame.withSeries' to be a Series object or a function that takes a dataframe and produces a Series.");
            }
        }
        else {
            chai_1.assert.isUndefined(series, "Expected 'series' parameter to 'DataFrame.withSeries' to not be set when 'columnNameOrSpec is an object.");
        }
        if (Sugar.Object.isObject(columnNameOrSpec)) {
            var columnSpec = columnNameOrSpec;
            var columnNames = Object.keys(columnSpec);
            var workingDataFrame = this;
            try {
                for (var columnNames_2 = __values(columnNames), columnNames_2_1 = columnNames_2.next(); !columnNames_2_1.done; columnNames_2_1 = columnNames_2.next()) {
                    var columnName_1 = columnNames_2_1.value;
                    workingDataFrame = workingDataFrame.withSeries(columnName_1, columnSpec[columnName_1]);
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (columnNames_2_1 && !columnNames_2_1.done && (_a = columnNames_2.return)) _a.call(columnNames_2);
                }
                finally { if (e_5) throw e_5.error; }
            }
            return workingDataFrame;
        }
        var columnName = columnNameOrSpec;
        if (this.none()) { // We have an empty data frame.
            var importSeries = void 0;
            if (Sugar.Object.isFunction(series)) {
                importSeries = series(this);
            }
            else {
                importSeries = series;
            }
            return importSeries.inflate(function (value) {
                var row = {};
                row[columnName] = value;
                return row;
            });
        }
        return new DataFrame(function () {
            var importSeries;
            if (Sugar.Object.isFunction(series)) {
                importSeries = series(_this);
            }
            else {
                importSeries = series;
            }
            var seriesValueMap = utils_1.toMap(importSeries.toPairs(), function (pair) { return pair[0]; }, function (pair) { return pair[1]; });
            var newColumnNames = utils_1.makeDistinct(_this.getColumnNames().concat([columnName]));
            return {
                columnNames: newColumnNames,
                index: _this.getContent().index,
                pairs: new select_iterable_1.SelectIterable(_this.getContent().pairs, function (pair) {
                    var index = pair[0];
                    var value = pair[1];
                    var modified = Object.assign({}, value);
                    modified[columnName] = seriesValueMap[index];
                    return [
                        index,
                        modified
                    ];
                }),
            };
        });
        var e_5, _a;
    };
    /**
     * Add a series if it doesn't already exist.
     *
     * @param columnNameOrSpec - The name of the series to add or a column spec that defines the new column.
     * @param series - The series to add to the dataframe. Can also be a function that returns the series.
     *
     * @returns Returns a new dataframe with the specified series added, if the series didn't already exist. Otherwise if the requested series already exists the same dataframe is returned.
     */
    DataFrame.prototype.ensureSeries = function (columnNameOrSpec, series) {
        if (!Sugar.Object.isObject(columnNameOrSpec)) {
            chai_1.assert.isString(columnNameOrSpec, "Expected 'columnNameOrSpec' parameter to 'DataFrame.ensureSeries' function to be a string that specifies the column to set or replace.");
            if (!Sugar.Object.isFunction(series)) {
                chai_1.assert.isObject(series, "Expected 'series' parameter to 'DataFrame.ensureSeries' to be a Series object or a function that takes a dataframe and produces a Series.");
            }
        }
        else {
            chai_1.assert.isUndefined(series, "Expected 'series' parameter to 'DataFrame.ensureSeries' to not be set when 'columnNameOrSpec is an object.");
        }
        if (Sugar.Object.isObject(columnNameOrSpec)) {
            var columnSpec = columnNameOrSpec;
            var columnNames = Object.keys(columnNameOrSpec);
            var workingDataFrame = this;
            try {
                for (var columnNames_3 = __values(columnNames), columnNames_3_1 = columnNames_3.next(); !columnNames_3_1.done; columnNames_3_1 = columnNames_3.next()) {
                    var columnName_2 = columnNames_3_1.value;
                    workingDataFrame = workingDataFrame.ensureSeries(columnName_2, columnSpec[columnName_2]);
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (columnNames_3_1 && !columnNames_3_1.done && (_a = columnNames_3.return)) _a.call(columnNames_3);
                }
                finally { if (e_6) throw e_6.error; }
            }
            return workingDataFrame;
        }
        var columnName = columnNameOrSpec;
        if (this.hasSeries(columnName)) {
            return this; // Already have the series.
        }
        else {
            return this.withSeries(columnName, series);
        }
        var e_6, _a;
    };
    /**
     * Create a new data-frame from a subset of columns.
     *
     * @param columnNames - Array of column names to include in the new data-frame.
     *
     * @returns Returns a dataframe with a subset of columns from the input dataframe.
     */
    DataFrame.prototype.subset = function (columnNames) {
        var _this = this;
        chai_1.assert.isArray(columnNames, "Expected 'columnNames' parameter to 'DataFrame.subset' to be an array of column names to keep.");
        return new DataFrame(function () {
            var content = _this.getContent();
            return {
                columnNames: columnNames,
                index: content.index,
                values: new select_iterable_1.SelectIterable(content.values, function (value) {
                    var output = {};
                    try {
                        for (var columnNames_4 = __values(columnNames), columnNames_4_1 = columnNames_4.next(); !columnNames_4_1.done; columnNames_4_1 = columnNames_4.next()) {
                            var columnName = columnNames_4_1.value;
                            output[columnName] = value[columnName];
                        }
                    }
                    catch (e_7_1) { e_7 = { error: e_7_1 }; }
                    finally {
                        try {
                            if (columnNames_4_1 && !columnNames_4_1.done && (_a = columnNames_4.return)) _a.call(columnNames_4);
                        }
                        finally { if (e_7) throw e_7.error; }
                    }
                    return output;
                    var e_7, _a;
                }),
                pairs: new select_iterable_1.SelectIterable(content.pairs, function (pair) {
                    var output = {};
                    var value = pair[1];
                    try {
                        for (var columnNames_5 = __values(columnNames), columnNames_5_1 = columnNames_5.next(); !columnNames_5_1.done; columnNames_5_1 = columnNames_5.next()) {
                            var columnName = columnNames_5_1.value;
                            output[columnName] = value[columnName];
                        }
                    }
                    catch (e_8_1) { e_8 = { error: e_8_1 }; }
                    finally {
                        try {
                            if (columnNames_5_1 && !columnNames_5_1.done && (_a = columnNames_5.return)) _a.call(columnNames_5);
                        }
                        finally { if (e_8) throw e_8.error; }
                    }
                    return [pair[0], output];
                    var e_8, _a;
                }),
            };
        });
    };
    ;
    /**
     * Create a new data frame with the requested column or columns dropped.
     *
     * @param columnOrColumns - Specifies the column name (a string) or columns (array of column names) to drop.
     *
     * @returns Returns a new dataframe with a particular name column or columns removed.
     */
    DataFrame.prototype.dropSeries = function (columnOrColumns) {
        var _this = this;
        if (!Sugar.Object.isArray(columnOrColumns)) {
            chai_1.assert.isString(columnOrColumns, "'DataFrame.dropSeries' expected either a string or an array or strings.");
            columnOrColumns = [columnOrColumns]; // Convert to array for coding convenience.
        }
        return new DataFrame(function () {
            var content = _this.getContent();
            var newColumnNames = [];
            try {
                for (var _a = __values(content.columnNames), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var columnName = _b.value;
                    if (columnOrColumns.indexOf(columnName) === -1) {
                        newColumnNames.push(columnName); // This column is not being dropped.
                    }
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_9) throw e_9.error; }
            }
            return {
                columnNames: newColumnNames,
                index: content.index,
                values: new select_iterable_1.SelectIterable(content.values, function (value) {
                    var clone = Object.assign({}, value);
                    try {
                        for (var columnOrColumns_1 = __values(columnOrColumns), columnOrColumns_1_1 = columnOrColumns_1.next(); !columnOrColumns_1_1.done; columnOrColumns_1_1 = columnOrColumns_1.next()) {
                            var droppedColumnName = columnOrColumns_1_1.value;
                            delete clone[droppedColumnName];
                        }
                    }
                    catch (e_10_1) { e_10 = { error: e_10_1 }; }
                    finally {
                        try {
                            if (columnOrColumns_1_1 && !columnOrColumns_1_1.done && (_a = columnOrColumns_1.return)) _a.call(columnOrColumns_1);
                        }
                        finally { if (e_10) throw e_10.error; }
                    }
                    return clone;
                    var e_10, _a;
                }),
                pairs: new select_iterable_1.SelectIterable(content.pairs, function (pair) {
                    var clone = Object.assign({}, pair[1]);
                    try {
                        for (var columnOrColumns_2 = __values(columnOrColumns), columnOrColumns_2_1 = columnOrColumns_2.next(); !columnOrColumns_2_1.done; columnOrColumns_2_1 = columnOrColumns_2.next()) {
                            var droppedColumnName = columnOrColumns_2_1.value;
                            delete clone[droppedColumnName];
                        }
                    }
                    catch (e_11_1) { e_11 = { error: e_11_1 }; }
                    finally {
                        try {
                            if (columnOrColumns_2_1 && !columnOrColumns_2_1.done && (_a = columnOrColumns_2.return)) _a.call(columnOrColumns_2);
                        }
                        finally { if (e_11) throw e_11.error; }
                    }
                    return [pair[0], clone];
                    var e_11, _a;
                }),
            };
            var e_9, _c;
        });
    };
    /**
     * Create a new data frame with columns reordered.
     * New column names create new columns (with undefined values), omitting existing column names causes those columns to be dropped.
     *
     * @param columnNames - The new order for columns.
     *
     * @returns Returns a new dataframe with columns remapped according to the specified column layout.
     */
    DataFrame.prototype.reorderSeries = function (columnNames) {
        var _this = this;
        chai_1.assert.isArray(columnNames, "Expected parameter 'columnNames' to 'DataFrame.reorderSeries' to be an array with column names.");
        try {
            for (var columnNames_6 = __values(columnNames), columnNames_6_1 = columnNames_6.next(); !columnNames_6_1.done; columnNames_6_1 = columnNames_6.next()) {
                var columnName = columnNames_6_1.value;
                chai_1.assert.isString(columnName, "Expected parameter 'columnNames' to 'DataFrame.reorderSeries' to be an array with column names.");
            }
        }
        catch (e_12_1) { e_12 = { error: e_12_1 }; }
        finally {
            try {
                if (columnNames_6_1 && !columnNames_6_1.done && (_a = columnNames_6.return)) _a.call(columnNames_6);
            }
            finally { if (e_12) throw e_12.error; }
        }
        return new DataFrame(function () {
            var content = _this.getContent();
            return {
                columnNames: columnNames,
                index: content.index,
                values: new select_iterable_1.SelectIterable(content.values, function (value) {
                    var output = {};
                    try {
                        for (var columnNames_7 = __values(columnNames), columnNames_7_1 = columnNames_7.next(); !columnNames_7_1.done; columnNames_7_1 = columnNames_7.next()) {
                            var columnName = columnNames_7_1.value;
                            output[columnName] = value[columnName];
                        }
                    }
                    catch (e_13_1) { e_13 = { error: e_13_1 }; }
                    finally {
                        try {
                            if (columnNames_7_1 && !columnNames_7_1.done && (_a = columnNames_7.return)) _a.call(columnNames_7);
                        }
                        finally { if (e_13) throw e_13.error; }
                    }
                    return output;
                    var e_13, _a;
                }),
                pairs: new select_iterable_1.SelectIterable(content.pairs, function (pair) {
                    var value = pair[1];
                    var output = {};
                    try {
                        for (var columnNames_8 = __values(columnNames), columnNames_8_1 = columnNames_8.next(); !columnNames_8_1.done; columnNames_8_1 = columnNames_8.next()) {
                            var columnName = columnNames_8_1.value;
                            output[columnName] = value[columnName];
                        }
                    }
                    catch (e_14_1) { e_14 = { error: e_14_1 }; }
                    finally {
                        try {
                            if (columnNames_8_1 && !columnNames_8_1.done && (_a = columnNames_8.return)) _a.call(columnNames_8);
                        }
                        finally { if (e_14) throw e_14.error; }
                    }
                    return [pair[0], output];
                    var e_14, _a;
                }),
            };
        });
        var e_12, _a;
    };
    /**
     * Bring the name column (or columns) to the front, making it (or them) the first column(s) in the data-frame.
     *
     * @param columnOrColumns - Specifies the column or columns to bring to the front.
     *
     * @returns Returns a new dataframe with 1 or more columns bought to the front of the column ordering.
     */
    DataFrame.prototype.bringToFront = function (columnOrColumns) {
        var _this = this;
        if (Sugar.Object.isArray(columnOrColumns)) {
            columnOrColumns.forEach(function (columnName) {
                chai_1.assert.isString(columnName, "Expect 'columnOrColumns' parameter to 'DataFrame.bringToFront' function to specify a column or columns via a string or an array of strings.");
            });
        }
        else {
            chai_1.assert.isString(columnOrColumns, "Expect 'columnOrColumns' parameter to 'DataFrame.bringToFront' function to specify a column or columns via a string or an array of strings.");
            columnOrColumns = [columnOrColumns]; // Convert to array for coding convenience.
        }
        return new DataFrame(function () {
            var content = _this.getContent();
            var existingColumns = Array.from(content.columnNames);
            var columnsToMove = [];
            try {
                for (var columnOrColumns_3 = __values(columnOrColumns), columnOrColumns_3_1 = columnOrColumns_3.next(); !columnOrColumns_3_1.done; columnOrColumns_3_1 = columnOrColumns_3.next()) {
                    var columnToMove = columnOrColumns_3_1.value;
                    if (existingColumns.indexOf(columnToMove) !== -1) {
                        // The request column actually exists, so we will move it.
                        columnsToMove.push(columnToMove);
                    }
                }
            }
            catch (e_15_1) { e_15 = { error: e_15_1 }; }
            finally {
                try {
                    if (columnOrColumns_3_1 && !columnOrColumns_3_1.done && (_a = columnOrColumns_3.return)) _a.call(columnOrColumns_3);
                }
                finally { if (e_15) throw e_15.error; }
            }
            var untouchedColumnNames = [];
            try {
                for (var existingColumns_1 = __values(existingColumns), existingColumns_1_1 = existingColumns_1.next(); !existingColumns_1_1.done; existingColumns_1_1 = existingColumns_1.next()) {
                    var existingColumnName = existingColumns_1_1.value;
                    if (columnOrColumns.indexOf(existingColumnName) === -1) {
                        untouchedColumnNames.push(existingColumnName);
                    }
                }
            }
            catch (e_16_1) { e_16 = { error: e_16_1 }; }
            finally {
                try {
                    if (existingColumns_1_1 && !existingColumns_1_1.done && (_b = existingColumns_1.return)) _b.call(existingColumns_1);
                }
                finally { if (e_16) throw e_16.error; }
            }
            return {
                columnNames: columnsToMove.concat(untouchedColumnNames),
                index: content.index,
                values: content.values,
                pairs: content.pairs,
            };
            var e_15, _a, e_16, _b;
        });
    };
    /**
     * Bring the name column (or columns) to the back, making it (or them) the last column(s) in the data-frame.
     *
     * @param columnOrColumns - Specifies the column or columns to bring to the back.
     *
     * @returns Returns a new dataframe with 1 or more columns bought to the back of the column ordering.
     */
    DataFrame.prototype.bringToBack = function (columnOrColumns) {
        var _this = this;
        if (Sugar.Object.isArray(columnOrColumns)) {
            columnOrColumns.forEach(function (columnName) {
                chai_1.assert.isString(columnName, "Expect 'columnOrColumns' parameter to 'DataFrame.bringToBack' function to specify a column or columns via a string or an array of strings.");
            });
        }
        else {
            chai_1.assert.isString(columnOrColumns, "Expect 'columnOrColumns' parameter to 'DataFrame.bringToBack' function to specify a column or columns via a string or an array of strings.");
            columnOrColumns = [columnOrColumns]; // Convert to array for coding convenience.
        }
        return new DataFrame(function () {
            var content = _this.getContent();
            var existingColumns = Array.from(content.columnNames);
            var columnsToMove = [];
            try {
                for (var columnOrColumns_4 = __values(columnOrColumns), columnOrColumns_4_1 = columnOrColumns_4.next(); !columnOrColumns_4_1.done; columnOrColumns_4_1 = columnOrColumns_4.next()) {
                    var columnToMove = columnOrColumns_4_1.value;
                    if (existingColumns.indexOf(columnToMove) !== -1) {
                        // The request column actually exists, so we will move it.
                        columnsToMove.push(columnToMove);
                    }
                }
            }
            catch (e_17_1) { e_17 = { error: e_17_1 }; }
            finally {
                try {
                    if (columnOrColumns_4_1 && !columnOrColumns_4_1.done && (_a = columnOrColumns_4.return)) _a.call(columnOrColumns_4);
                }
                finally { if (e_17) throw e_17.error; }
            }
            var untouchedColumnNames = [];
            try {
                for (var existingColumns_2 = __values(existingColumns), existingColumns_2_1 = existingColumns_2.next(); !existingColumns_2_1.done; existingColumns_2_1 = existingColumns_2.next()) {
                    var existingColumnName = existingColumns_2_1.value;
                    if (columnOrColumns.indexOf(existingColumnName) === -1) {
                        untouchedColumnNames.push(existingColumnName);
                    }
                }
            }
            catch (e_18_1) { e_18 = { error: e_18_1 }; }
            finally {
                try {
                    if (existingColumns_2_1 && !existingColumns_2_1.done && (_b = existingColumns_2.return)) _b.call(existingColumns_2);
                }
                finally { if (e_18) throw e_18.error; }
            }
            return {
                columnNames: untouchedColumnNames.concat(columnsToMove),
                index: content.index,
                values: content.values,
                pairs: content.pairs,
            };
            var e_17, _a, e_18, _b;
        });
    };
    /**
     * Create a new data-frame with renamed series.
     *
     * @param newColumnNames - A column rename spec - maps existing column names to new column names.
     *
     * @returns Returns a new dataframe with columns renamed.
     */
    DataFrame.prototype.renameSeries = function (newColumnNames) {
        var _this = this;
        chai_1.assert.isObject(newColumnNames, "Expected parameter 'newColumnNames' to 'DataFrame.renameSeries' to be an array with column names.");
        var existingColumnsToRename = Object.keys(newColumnNames);
        try {
            for (var existingColumnsToRename_1 = __values(existingColumnsToRename), existingColumnsToRename_1_1 = existingColumnsToRename_1.next(); !existingColumnsToRename_1_1.done; existingColumnsToRename_1_1 = existingColumnsToRename_1.next()) {
                var existingColumnName = existingColumnsToRename_1_1.value;
                chai_1.assert.isString(existingColumnName, "Expected existing column name '" + existingColumnName + "' of 'newColumnNames' parameter to 'DataFrame.renameSeries' to be a string.");
                chai_1.assert.isString(newColumnNames[existingColumnName], "Expected new column name '" + newColumnNames[existingColumnName] + "' for existing column '" + existingColumnName + "' of 'newColumnNames' parameter to 'DataFrame.renameSeries' to be a string.");
            }
        }
        catch (e_19_1) { e_19 = { error: e_19_1 }; }
        finally {
            try {
                if (existingColumnsToRename_1_1 && !existingColumnsToRename_1_1.done && (_a = existingColumnsToRename_1.return)) _a.call(existingColumnsToRename_1);
            }
            finally { if (e_19) throw e_19.error; }
        }
        return new DataFrame(function () {
            var content = _this.getContent();
            var renamedColumns = [];
            try {
                for (var _a = __values(content.columnNames), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var existingColumnName = _b.value;
                    var columnIndex = existingColumnsToRename.indexOf(existingColumnName);
                    if (columnIndex === -1) {
                        renamedColumns.push(existingColumnName); // This column is not renamed.                    
                    }
                    else {
                        renamedColumns.push(newColumnNames[existingColumnName]); // This column is renamed.
                    }
                }
            }
            catch (e_20_1) { e_20 = { error: e_20_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_20) throw e_20.error; }
            }
            //
            // Remap each row of the data frame to the new column names.
            //
            function remapValue(value) {
                var clone = Object.assign({}, value);
                try {
                    for (var existingColumnsToRename_2 = __values(existingColumnsToRename), existingColumnsToRename_2_1 = existingColumnsToRename_2.next(); !existingColumnsToRename_2_1.done; existingColumnsToRename_2_1 = existingColumnsToRename_2.next()) {
                        var existingColumName = existingColumnsToRename_2_1.value;
                        clone[newColumnNames[existingColumName]] = clone[existingColumName];
                        delete clone[existingColumName];
                    }
                }
                catch (e_21_1) { e_21 = { error: e_21_1 }; }
                finally {
                    try {
                        if (existingColumnsToRename_2_1 && !existingColumnsToRename_2_1.done && (_a = existingColumnsToRename_2.return)) _a.call(existingColumnsToRename_2);
                    }
                    finally { if (e_21) throw e_21.error; }
                }
                return clone;
                var e_21, _a;
            }
            return {
                columnNames: renamedColumns,
                index: content.index,
                values: new select_iterable_1.SelectIterable(content.values, remapValue),
                pairs: new select_iterable_1.SelectIterable(content.pairs, function (pair) {
                    return [pair[0], remapValue(pair[1])];
                }),
            };
            var e_20, _c;
        });
        var e_19, _a;
    };
    ;
    /**
    * Extract values from the dataframe as an array.
    * This forces lazy evaluation to complete.
    *
    * @returns Returns an array of values contained within the dataframe.
    */
    DataFrame.prototype.toArray = function () {
        var values = [];
        try {
            for (var _a = __values(this.getContent().values), _b = _a.next(); !_b.done; _b = _a.next()) {
                var value = _b.value;
                if (value !== undefined) {
                    values.push(value);
                }
            }
        }
        catch (e_22_1) { e_22 = { error: e_22_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_22) throw e_22.error; }
        }
        return values;
        var e_22, _c;
    };
    /**
     * Retreive the index and values from the DataFrame as an array of pairs.
     * Each pair is [index, value].
     * This forces lazy evaluation to complete.
     *
     * @returns Returns an array of pairs that contains the dataframe content. Each pair is a two element array that contains an index and a value.
     */
    DataFrame.prototype.toPairs = function () {
        var pairs = [];
        try {
            for (var _a = __values(this.getContent().pairs), _b = _a.next(); !_b.done; _b = _a.next()) {
                var pair = _b.value;
                if (pair[1] != undefined) {
                    pairs.push(pair);
                }
            }
        }
        catch (e_23_1) { e_23 = { error: e_23_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_23) throw e_23.error; }
        }
        return pairs;
        var e_23, _c;
    };
    /**
     * Convert the dataframe to a JavaScript object.
     *
     * @param keySelector - Function that selects keys for the resulting object.
     * @param valueSelector - Function that selects values for the resulting object.
     *
     * @returns Returns a JavaScript object generated from the input sequence by the key and value selector funtions.
     */
    DataFrame.prototype.toObject = function (keySelector, valueSelector) {
        chai_1.assert.isFunction(keySelector, "Expected 'keySelector' parameter to DataFrame.toObject to be a function.");
        chai_1.assert.isFunction(valueSelector, "Expected 'valueSelector' parameter to DataFrame.toObject to be a function.");
        return utils_1.toMap(this, keySelector, valueSelector);
    };
    /**
     * Bake the data frame to an array of rows.
     *
     *  @returns Returns an array of rows. Each row is an array of values in column order.
     */
    DataFrame.prototype.toRows = function () {
        var columnNames = this.getColumnNames();
        var rows = [];
        try {
            for (var _a = __values(this.getContent().values), _b = _a.next(); !_b.done; _b = _a.next()) {
                var value = _b.value;
                var row = [];
                for (var columnIndex = 0; columnIndex < columnNames.length; ++columnIndex) {
                    row.push(value[columnNames[columnIndex]]);
                }
                rows.push(row);
            }
        }
        catch (e_24_1) { e_24 = { error: e_24_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_24) throw e_24.error; }
        }
        return rows;
        var e_24, _c;
    };
    /**
     * Generate a new dataframe based by calling the selector function on each value.
     *
     * @param selector Selector function that transforms each value to create a new dataframe.
     *
     * @returns Returns a new dataframe that has been transformed by the selector function.
     */
    DataFrame.prototype.select = function (selector) {
        var _this = this;
        chai_1.assert.isFunction(selector, "Expected 'selector' parameter to 'DataFrame.select' function to be a function.");
        return new DataFrame(function () {
            var content = _this.getContent();
            return {
                values: new select_iterable_1.SelectIterable(content.values, selector),
                index: content.index,
            };
        });
    };
    /**
     * Generate a new dataframe based on the results of the selector function.
     *
     * @param selector Selector function that transforms each value into a list of values.
     *
     * @returns  Returns a new dataframe with values that have been produced by the selector function.
     */
    DataFrame.prototype.selectMany = function (selector) {
        var _this = this;
        chai_1.assert.isFunction(selector, "Expected 'selector' parameter to 'DataFrame.selectMany' to be a function.");
        return new DataFrame(function () { return ({
            pairs: new select_many_iterable_1.SelectManyIterable(_this.getContent().pairs, function (pair, index) {
                var outputPairs = [];
                try {
                    for (var _a = __values(selector(pair[1], index)), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var transformed = _b.value;
                        outputPairs.push([
                            pair[0],
                            transformed
                        ]);
                    }
                }
                catch (e_25_1) { e_25 = { error: e_25_1 }; }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_25) throw e_25.error; }
                }
                return outputPairs;
                var e_25, _c;
            })
        }); });
    };
    /**
     * Transform one or more columns. This is equivalent to extracting a column, calling 'select' on it,
     * then plugging it back in as the same column.
     *
     * @param columnSelectors - Object with field names for each column to be transformed. Each field you be a selector that transforms that column.
     *
     * @returns Returns a new dataframe with 1 or more columns transformed.
     */
    DataFrame.prototype.transformSeries = function (columnSelectors) {
        chai_1.assert.isObject(columnSelectors, "Expected 'columnSelectors' parameter of 'DataFrame.transformSeries' function to be an object. Field names should specify columns to transform. Field values should be selector functions that specify the transformation for each column.");
        var working = this;
        try {
            for (var _a = __values(Object.keys(columnSelectors)), _b = _a.next(); !_b.done; _b = _a.next()) {
                var columnName = _b.value;
                if (working.hasSeries(columnName)) {
                    working = working.withSeries(columnName, working.getSeries(columnName)
                        .select(columnSelectors[columnName]));
                }
            }
        }
        catch (e_26_1) { e_26 = { error: e_26_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_26) throw e_26.error; }
        }
        return working;
        var e_26, _c;
    };
    /**
     * Generate new columns based on existing rows.
     *
     * @param generator - Generator function that transforms each row to a new set of columns.
     *
     * @returns Returns a new dataframe with 1 or more new columns.
     */
    DataFrame.prototype.generateSeries = function (generator) {
        if (!Sugar.Object.isObject(generator)) {
            chai_1.assert.isFunction(generator, "Expected 'generator' parameter to 'DataFrame.generateSeries' function to be a function or an object.");
            var selector = generator;
            var newColumns = this.select(selector) // Build a new dataframe.
                .bake(); //TODO: Bake should be needed here, but it causes problems if not.
            var newColumnNames = newColumns.getColumnNames();
            var working = this;
            try {
                //TODO: There must be a cheaper implementation!
                for (var newColumnNames_1 = __values(newColumnNames), newColumnNames_1_1 = newColumnNames_1.next(); !newColumnNames_1_1.done; newColumnNames_1_1 = newColumnNames_1.next()) {
                    var newColumnName = newColumnNames_1_1.value;
                    working = working.withSeries(newColumnName, newColumns.getSeries(newColumnName));
                }
            }
            catch (e_27_1) { e_27 = { error: e_27_1 }; }
            finally {
                try {
                    if (newColumnNames_1_1 && !newColumnNames_1_1.done && (_a = newColumnNames_1.return)) _a.call(newColumnNames_1);
                }
                finally { if (e_27) throw e_27.error; }
            }
            return working;
        }
        else {
            var columnTransformSpec = generator;
            var newColumnNames = Object.keys(columnTransformSpec);
            var working = this;
            try {
                for (var newColumnNames_2 = __values(newColumnNames), newColumnNames_2_1 = newColumnNames_2.next(); !newColumnNames_2_1.done; newColumnNames_2_1 = newColumnNames_2.next()) {
                    var newColumnName = newColumnNames_2_1.value;
                    working = working.withSeries(newColumnName, working.select(columnTransformSpec[newColumnName]).deflate());
                }
            }
            catch (e_28_1) { e_28 = { error: e_28_1 }; }
            finally {
                try {
                    if (newColumnNames_2_1 && !newColumnNames_2_1.done && (_b = newColumnNames_2.return)) _b.call(newColumnNames_2);
                }
                finally { if (e_28) throw e_28.error; }
            }
            return working;
        }
        var e_27, _a, e_28, _b;
    };
    /**
     * Deflate a data-frame to a series.
     *
     * @param [selector] - Optional selector function that transforms each row to a new sequence of values.
     *
     * @returns Returns a series that was created from the input dataframe.
     */
    DataFrame.prototype.deflate = function (selector) {
        var _this = this;
        if (selector) {
            chai_1.assert.isFunction(selector, "Expected 'selector' parameter to 'DataFrame.deflate' function to be a selector function.");
        }
        return new series_1.Series(function () {
            var content = _this.getContent();
            if (selector) {
                return {
                    index: content.index,
                    values: new select_iterable_1.SelectIterable(content.values, selector),
                    pairs: new select_iterable_1.SelectIterable(content.pairs, function (pair, index) {
                        return [
                            pair[0],
                            selector(pair[1], index)
                        ];
                    }),
                };
            }
            else {
                return {
                    index: content.index,
                    values: content.values,
                    pairs: content.pairs,
                };
            }
        });
    };
    ;
    /**
     * Inflate a named series in the data-frame to 1 or more new series in the new dataframe.
     *
     * @param columnName - Name or index of the column to retreive.
     * @param [selector] - Optional selector function that transforms each value in the column to new columns. If not specified it is expected that each value in the column is an object whose fields define the new column names.
     *
     * @returns Returns a new dataframe with a column inflated to 1 or more new columns.
     */
    DataFrame.prototype.inflateSeries = function (columnName, selector) {
        chai_1.assert.isString(columnName, "Expected 'columnName' parameter to 'DataFrame.inflateSeries' to be a string that is the name of the column to inflate.");
        if (selector) {
            chai_1.assert.isFunction(selector, "Expected optional 'selector' parameter to 'DataFrame.inflateSeries' to be a selector function, if it is specified.");
        }
        return this.zip(this.getSeries(columnName).inflate(selector), function (row1, row2) { return Object.assign({}, row1, row2); } //todo: this be should zip's default operation.
        );
    };
    /**
     * Segment a dataframe into 'windows'. Returns a new series. Each value in the new series contains a 'window' (or segment) of the original dataframe.
     * Use select or selectPairs to aggregate.
     *
     * @param period - The number of values in the window.
     *
     * @returns Returns a new series, each value of which is a 'window' (or segment) of the original dataframe.
     */
    DataFrame.prototype.window = function (period) {
        var _this = this;
        chai_1.assert.isNumber(period, "Expected 'period' parameter to 'DataFrame.window' to be a number.");
        return new series_1.Series(function () {
            var content = _this.getContent();
            return {
                values: new dataframe_window_iterable_1.DataFrameWindowIterable(content.columnNames, content.pairs, period)
            };
        });
    };
    /**
     * Segment a dataframe into 'rolling windows'. Returns a new series. Each value in the new series contains a 'window' (or segment) of the original series.
    *
     * @param period - The number of values in the window.
     *
     * @returns Returns a new series, each value of which is a 'window' (or segment) of the original series.
     */
    DataFrame.prototype.rollingWindow = function (period) {
        var _this = this;
        chai_1.assert.isNumber(period, "Expected 'period' parameter to 'DataFrame.rollingWindow' to be a number.");
        return new series_1.Series(function () {
            var content = _this.getContent();
            return {
                values: new dataframe_rolling_window_iterable_1.DataFrameRollingWindowIterable(content.columnNames, content.pairs, period)
            };
        });
    };
    /**
     * Groups sequential values into variable length 'windows'.
     *
     * @param comparer - Predicate that compares two values and returns true if they should be in the same window.
     *
     * @returns Returns a series of groups. Each group is itself a series that contains the values in the 'window'.
     */
    DataFrame.prototype.variableWindow = function (comparer) {
        var _this = this;
        chai_1.assert.isFunction(comparer, "Expected 'comparer' parameter to 'DataFrame.variableWindow' to be a function.");
        return new series_1.Series(function () {
            var content = _this.getContent();
            return {
                values: new dataframe_variable_window_iterable_1.DataFrameVariableWindowIterable(content.columnNames, content.pairs, comparer)
            };
        });
    };
    /**
     * Group sequential duplicate values into a series of windows.
     *
     * @param [selector] - Optional selector function to determine the value used to compare for duplicates.
     *
     * @returns Returns a series of groups. Each group is itself a series.
     */
    DataFrame.prototype.sequentialDistinct = function (selector) {
        if (selector) {
            chai_1.assert.isFunction(selector, "Expected 'selector' parameter to 'DataFrame.sequentialDistinct' to be a selector function that determines the value to compare for duplicates.");
        }
        else {
            selector = function (value) { return value; };
        }
        return this.variableWindow(function (a, b) { return selector(a) === selector(b); })
            .select(function (window) {
            return [window.getIndex().first(), window.first()];
        })
            .withIndex(function (pair) { return pair[0]; })
            .inflate(function (pair) { return pair[1]; });
    };
    /**
     * Aggregate the values in the dataframe.
     *
     * @param [seed] - Optional seed value for producing the aggregation.
     * @param selector - Function that takes the seed and then each value in the dataframe and produces the aggregate value.
     *
     * @returns Returns a new value that has been aggregated from the input sequence by the 'selector' function.
     */
    DataFrame.prototype.aggregate = function (seedOrSelector, selector) {
        var _this = this;
        if (Sugar.Object.isFunction(seedOrSelector) && !selector) {
            return this.skip(1).aggregate(this.first(), seedOrSelector);
        }
        else if (selector) {
            chai_1.assert.isFunction(selector, "Expected 'selector' parameter to aggregate to be a function.");
            var accum = seedOrSelector;
            try {
                for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var value = _b.value;
                    accum = selector(accum, value);
                }
            }
            catch (e_29_1) { e_29 = { error: e_29_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_29) throw e_29.error; }
            }
            return accum;
        }
        else {
            chai_1.assert.isObject(seedOrSelector, "Expected 'seed' parameter to aggregate to be an object.");
            var columnAggregateSpec_1 = seedOrSelector;
            var columnNames = Object.keys(columnAggregateSpec_1);
            var aggregatedColumns = columnNames.map(function (columnName) {
                var columnSelector = columnAggregateSpec_1[columnName];
                chai_1.assert.isFunction(columnSelector, "Expected column/selector pairs in 'seed' parameter to aggregate.");
                return [columnName, _this.getSeries(columnName).aggregate(columnSelector)];
            });
            return utils_1.toMap(aggregatedColumns, function (pair) { return pair[0]; }, function (pair) { return pair[1]; });
        }
        var e_29, _c;
    };
    /**
     * Skip a number of values in the dataframe.
     *
     * @param numValues - Number of values to skip.
     * @returns Returns a new dataframe or dataframe with the specified number of values skipped.
     */
    DataFrame.prototype.skip = function (numValues) {
        var _this = this;
        return new DataFrame(function () {
            var content = _this.getContent();
            return {
                columnNames: content.columnNames,
                values: new skip_iterable_1.SkipIterable(content.values, numValues),
                index: new skip_iterable_1.SkipIterable(content.index, numValues),
                pairs: new skip_iterable_1.SkipIterable(content.pairs, numValues),
            };
        });
    };
    /**
     * Skips values in the series while a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series with all initial sequential values removed that match the predicate.
     */
    DataFrame.prototype.skipWhile = function (predicate) {
        var _this = this;
        chai_1.assert.isFunction(predicate, "Expected 'predicate' parameter to 'DataFrame.skipWhile' function to be a predicate function that returns true/false.");
        return new DataFrame(function () {
            var content = _this.getContent();
            return {
                columnNames: content.columnNames,
                values: new skip_while_iterable_1.SkipWhileIterable(content.values, predicate),
                pairs: new skip_while_iterable_1.SkipWhileIterable(content.pairs, function (pair) { return predicate(pair[1]); }),
            };
        });
    };
    /**
     * Skips values in the series until a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series with all initial sequential values removed that don't match the predicate.
     */
    DataFrame.prototype.skipUntil = function (predicate) {
        chai_1.assert.isFunction(predicate, "Expected 'predicate' parameter to 'DataFrame.skipUntil' function to be a predicate function that returns true/false.");
        return this.skipWhile(function (value) { return !predicate(value); });
    };
    /**
     * Take a number of rows in the series.
     *
     * @param numRows - Number of rows to take.
     *
     * @returns Returns a new series with up to the specified number of values included.
     */
    DataFrame.prototype.take = function (numRows) {
        var _this = this;
        chai_1.assert.isNumber(numRows, "Expected 'numRows' parameter to 'DataFrame.take' function to be a number.");
        return new DataFrame(function () {
            var content = _this.getContent();
            return {
                columnNames: content.columnNames,
                index: new take_iterable_1.TakeIterable(content.index, numRows),
                values: new take_iterable_1.TakeIterable(content.values, numRows),
                pairs: new take_iterable_1.TakeIterable(content.pairs, numRows)
            };
        });
    };
    ;
    /**
     * Take values from the series while a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series that only includes the initial sequential values that have matched the predicate.
     */
    DataFrame.prototype.takeWhile = function (predicate) {
        var _this = this;
        chai_1.assert.isFunction(predicate, "Expected 'predicate' parameter to 'DataFrame.takeWhile' function to be a predicate function that returns true/false.");
        return new DataFrame(function () {
            var content = _this.getContent();
            return {
                columnNames: content.columnNames,
                values: new take_while_iterable_1.TakeWhileIterable(content.values, predicate),
                pairs: new take_while_iterable_1.TakeWhileIterable(content.pairs, function (pair) { return predicate(pair[1]); })
            };
        });
    };
    /**
     * Take values from the series until a condition is met.
     *
     * @param predicate - Return true to indicate the condition met.
     *
     * @returns Returns a new series or dataframe that only includes the initial sequential values that have not matched the predicate.
     */
    DataFrame.prototype.takeUntil = function (predicate) {
        chai_1.assert.isFunction(predicate, "Expected 'predicate' parameter to 'DataFrame.takeUntil' function to be a predicate function that returns true/false.");
        return this.takeWhile(function (value) { return !predicate(value); });
    };
    /**
     * Count the number of values in the series.
     *
     * @returns Returns the count of all values in the series.
     */
    DataFrame.prototype.count = function () {
        var total = 0;
        try {
            for (var _a = __values(this.getContent().values), _b = _a.next(); !_b.done; _b = _a.next()) {
                var value = _b.value;
                ++total;
            }
        }
        catch (e_30_1) { e_30 = { error: e_30_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_30) throw e_30.error; }
        }
        return total;
        var e_30, _c;
    };
    /**
     * Get the first value of the series.
     *
     * @returns Returns the first value of the series.
     */
    DataFrame.prototype.first = function () {
        try {
            for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                var value = _b.value;
                return value; // Only need the first value.
            }
        }
        catch (e_31_1) { e_31 = { error: e_31_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_31) throw e_31.error; }
        }
        throw new Error("No values in Series.");
        var e_31, _c;
    };
    /**
     * Get the last value of the series.
     *
     * @returns Returns the last value of the series.
     */
    DataFrame.prototype.last = function () {
        var lastValue = null;
        try {
            for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                var value = _b.value;
                lastValue = value; // Throw away all values until we get to the last one.
            }
        }
        catch (e_32_1) { e_32 = { error: e_32_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_32) throw e_32.error; }
        }
        if (lastValue === null) {
            throw new Error("No values in Series.");
        }
        return lastValue;
        var e_32, _c;
    };
    /**
     * Get the value at a specified index.
     *
     * @param index - Index to for which to retreive the value.
     *
     * @returns Returns the value from the specified index in the sequence or undefined if there is no such index in the series.
     */
    DataFrame.prototype.at = function (index) {
        if (this.none()) {
            return undefined;
        }
        try {
            //
            // This is pretty expensive.
            // A specialised index could improve this.
            //
            for (var _a = __values(this.getContent().pairs), _b = _a.next(); !_b.done; _b = _a.next()) {
                var pair = _b.value;
                if (pair[0] === index) {
                    return pair[1];
                }
            }
        }
        catch (e_33_1) { e_33 = { error: e_33_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_33) throw e_33.error; }
        }
        return undefined;
        var e_33, _c;
    };
    /**
     * Get X values from the start of the dataframe.
     * Pass in a negative value to get all items at the head except X values at the tail.
     *
     * @param numValues - Number of values to take.
     *
     * @returns Returns a new dataframe that has only the specified number of values taken from the start of the input sequence.
     */
    DataFrame.prototype.head = function (numValues) {
        chai_1.assert.isNumber(numValues, "Expected 'numValues' parameter to 'DataFrame.head' function to be a number.");
        if (numValues === 0) {
            return new DataFrame(); // Empty dataframe.
        }
        var toTake = numValues < 0 ? this.count() - Math.abs(numValues) : numValues;
        return this.take(toTake);
    };
    /**
     * Get X values from the end of the dataframe.
     * Pass in a negative value to get all items at the tail except X values at the head.
     *
     * @param numValues - Number of values to take.
     *
     * @returns Returns a new dataframe that has only the specified number of values taken from the end of the input sequence.
     */
    DataFrame.prototype.tail = function (numValues) {
        chai_1.assert.isNumber(numValues, "Expected 'numValues' parameter to 'DataFrame.tail' function to be a number.");
        if (numValues === 0) {
            return new DataFrame(); // Empty dataframe.
        }
        var toSkip = numValues > 0 ? this.count() - numValues : Math.abs(numValues);
        return this.skip(toSkip);
    };
    /**
     * Filter a series by a predicate selector.
     *
     * @param predicate - Predicte function to filter rows of the series.
     *
     * @returns Returns a new series containing only the values that match the predicate.
     */
    DataFrame.prototype.where = function (predicate) {
        var _this = this;
        chai_1.assert.isFunction(predicate, "Expected 'predicate' parameter to 'DataFrame.where' function to be a function.");
        return new DataFrame(function () {
            var content = _this.getContent();
            return {
                columnNames: content.columnNames,
                values: new where_iterable_1.WhereIterable(content.values, predicate),
                pairs: new where_iterable_1.WhereIterable(content.pairs, function (pair) { return predicate(pair[1]); })
            };
        });
    };
    /**
     * Invoke a callback function for each value in the series.
     *
     * @param callback - The calback to invoke for each value.
     *
     * @returns Returns the input series with no modifications.
     */
    DataFrame.prototype.forEach = function (callback) {
        chai_1.assert.isFunction(callback, "Expected 'callback' parameter to 'DataFrame.forEach' to be a function.");
        var index = 0;
        try {
            for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                var value = _b.value;
                callback(value, index++);
            }
        }
        catch (e_34_1) { e_34 = { error: e_34_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_34) throw e_34.error; }
        }
        return this;
        var e_34, _c;
    };
    /**
     * Determine if the predicate returns truthy for all values in the series.
     * Returns false as soon as the predicate evaluates to falsy.
     * Returns true if the predicate returns truthy for all values in the series.
     * Returns false if the series is empty.
     *
     * @param predicate - Predicate function that receives each value in turn and returns truthy for a match, otherwise falsy.
     *
     * @returns {boolean} Returns true if the predicate has returned truthy for every value in the sequence, otherwise returns false.
     */
    DataFrame.prototype.all = function (predicate) {
        chai_1.assert.isFunction(predicate, "Expected 'predicate' parameter to 'DataFrame.all' to be a function.");
        var count = 0;
        try {
            for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                var value = _b.value;
                if (!predicate(value)) {
                    return false;
                }
                ++count;
            }
        }
        catch (e_35_1) { e_35 = { error: e_35_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_35) throw e_35.error; }
        }
        return count > 0;
        var e_35, _c;
    };
    /**
     * Determine if the predicate returns truthy for any of the values in the series.
     * Returns true as soon as the predicate returns truthy.
     * Returns false if the predicate never returns truthy.
     * If no predicate is specified the value itself is checked.
     *
     * @param [predicate] - Optional predicate function that receives each value in turn and returns truthy for a match, otherwise falsy.
     *
     * @returns Returns true if the predicate has returned truthy for any value in the sequence, otherwise returns false.
     */
    DataFrame.prototype.any = function (predicate) {
        if (predicate) {
            chai_1.assert.isFunction(predicate, "Expected 'predicate' parameter to 'DataFrame.any' to be a function.");
        }
        if (predicate) {
            try {
                // Use the predicate to check each value.
                for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var value = _b.value;
                    if (predicate(value)) {
                        return true;
                    }
                }
            }
            catch (e_36_1) { e_36 = { error: e_36_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_36) throw e_36.error; }
            }
        }
        else {
            try {
                // Check each value directly.
                for (var _d = __values(this), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var value = _e.value;
                    if (value) {
                        return true;
                    }
                }
            }
            catch (e_37_1) { e_37 = { error: e_37_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                }
                finally { if (e_37) throw e_37.error; }
            }
        }
        return false; // Nothing passed.
        var e_36, _c, e_37, _f;
    };
    /**
     * Determine if the predicate returns truthy for none of the values in the series.
     * Returns true for an empty series.
     * Returns true if the predicate always returns falsy.
     * Otherwise returns false.
     * If no predicate is specified the value itself is checked.
     *
     * @param [predicate] - Optional predicate function that receives each value in turn and returns truthy for a match, otherwise falsy.
     *
     * @returns Returns true if the predicate has returned truthy for no values in the series, otherwise returns false.
     */
    DataFrame.prototype.none = function (predicate) {
        if (predicate) {
            chai_1.assert.isFunction(predicate, "Expected 'predicate' parameter to 'DataFrame.none' to be a function.");
        }
        if (predicate) {
            try {
                // Use the predicate to check each value.
                for (var _a = __values(this), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var value = _b.value;
                    if (predicate(value)) {
                        return false;
                    }
                }
            }
            catch (e_38_1) { e_38 = { error: e_38_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_38) throw e_38.error; }
            }
        }
        else {
            try {
                // Check each value directly.
                for (var _d = __values(this), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var value = _e.value;
                    if (value) {
                        return false;
                    }
                }
            }
            catch (e_39_1) { e_39 = { error: e_39_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                }
                finally { if (e_39) throw e_39.error; }
            }
        }
        return true; // Nothing failed the predicate.
        var e_38, _c, e_39, _f;
    };
    /**
     * Get a new series containing all values starting at and after the specified index value.
     *
     * @param indexValue - The index value to search for before starting the new series.
     *
     * @returns Returns a new series containing all values starting at and after the specified index value.
     */
    DataFrame.prototype.startAt = function (indexValue) {
        var _this = this;
        return new DataFrame(function () {
            var content = _this.getContent();
            var lessThan = _this.getIndex().getLessThan();
            return {
                columnNames: content.columnNames,
                index: new skip_while_iterable_1.SkipWhileIterable(content.index, function (index) { return lessThan(index, indexValue); }),
                pairs: new skip_while_iterable_1.SkipWhileIterable(content.pairs, function (pair) { return lessThan(pair[0], indexValue); }),
            };
        });
    };
    /**
     * Get a new series containing all values up until and including the specified index value (inclusive).
     *
     * @param indexValue - The index value to search for before ending the new series.
     *
     * @returns Returns a new series containing all values up until and including the specified index value.
     */
    DataFrame.prototype.endAt = function (indexValue) {
        var _this = this;
        return new DataFrame(function () {
            var content = _this.getContent();
            var lessThanOrEqualTo = _this.getIndex().getLessThanOrEqualTo();
            return {
                columnNames: content.columnNames,
                index: new take_while_iterable_1.TakeWhileIterable(content.index, function (index) { return lessThanOrEqualTo(index, indexValue); }),
                pairs: new take_while_iterable_1.TakeWhileIterable(content.pairs, function (pair) { return lessThanOrEqualTo(pair[0], indexValue); }),
            };
        });
    };
    /**
     * Get a new series containing all values up to the specified index value (exclusive).
     *
     * @param indexValue - The index value to search for before ending the new series.
     *
     * @returns Returns a new series containing all values up to the specified inde value.
     */
    DataFrame.prototype.before = function (indexValue) {
        var _this = this;
        return new DataFrame(function () {
            var content = _this.getContent();
            var lessThan = _this.getIndex().getLessThan();
            return {
                columnNames: content.columnNames,
                index: new take_while_iterable_1.TakeWhileIterable(content.index, function (index) { return lessThan(index, indexValue); }),
                pairs: new take_while_iterable_1.TakeWhileIterable(content.pairs, function (pair) { return lessThan(pair[0], indexValue); }),
            };
        });
    };
    /**
     * Get a new series containing all values after the specified index value (exclusive).
     *
     * @param indexValue - The index value to search for.
     *
     * @returns Returns a new series containing all values after the specified index value.
     */
    DataFrame.prototype.after = function (indexValue) {
        var _this = this;
        return new DataFrame(function () {
            var content = _this.getContent();
            var lessThanOrEqualTo = _this.getIndex().getLessThanOrEqualTo();
            return {
                columnNames: content.columnNames,
                index: new skip_while_iterable_1.SkipWhileIterable(content.index, function (index) { return lessThanOrEqualTo(index, indexValue); }),
                pairs: new skip_while_iterable_1.SkipWhileIterable(content.pairs, function (pair) { return lessThanOrEqualTo(pair[0], indexValue); }),
            };
        });
    };
    /**
     * Get a new dataframe containing all values between the specified index values (inclusive).
     *
     * @param startIndexValue - The index where the new sequence starts.
     * @param endIndexValue - The index where the new sequence ends.
     *
     * @returns Returns a new dataframe containing all values between the specified index values (inclusive).
     */
    DataFrame.prototype.between = function (startIndexValue, endIndexValue) {
        return this.startAt(startIndexValue).endAt(endIndexValue);
    };
    /**
     * Format the dataframe for display as a string.
     * This forces lazy evaluation to complete.
     *
     * @returns Generates and returns a string representation of the dataframe or dataframe.
     */
    DataFrame.prototype.toString = function () {
        var columnNames = this.getColumnNames();
        var header = ["__index__"].concat(columnNames);
        var table = new Table();
        var _loop_1 = function (pair) {
            var index = pair[0];
            var value = pair[1];
            table.cell(header[0], index);
            columnNames.forEach(function (columnName, columnIndex) {
                table.cell(header[columnIndex + 1], value[columnName]);
            });
            table.newRow();
        };
        try {
            //TODO: for (const pair of this.asPairs()) {
            for (var _a = __values(this.toPairs()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var pair = _b.value;
                _loop_1(pair);
            }
        }
        catch (e_40_1) { e_40 = { error: e_40_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_40) throw e_40.error; }
        }
        return table.toString();
        var e_40, _c;
    };
    /**
     * Parse a column with string values to a column with int values.
     *
     * @param columnNameOrNames - Specifies the column name or array of column names to parse.
     *
     * @returns Returns a new dataframe with a particular named column parsed as ints.
     */
    DataFrame.prototype.parseInts = function (columnNameOrNames) {
        if (Sugar.Object.isArray(columnNameOrNames)) {
            var working = this;
            try {
                for (var columnNameOrNames_1 = __values(columnNameOrNames), columnNameOrNames_1_1 = columnNameOrNames_1.next(); !columnNameOrNames_1_1.done; columnNameOrNames_1_1 = columnNameOrNames_1.next()) {
                    var columnName = columnNameOrNames_1_1.value;
                    working = working.parseInts(columnName);
                }
            }
            catch (e_41_1) { e_41 = { error: e_41_1 }; }
            finally {
                try {
                    if (columnNameOrNames_1_1 && !columnNameOrNames_1_1.done && (_a = columnNameOrNames_1.return)) _a.call(columnNameOrNames_1);
                }
                finally { if (e_41) throw e_41.error; }
            }
            return working;
        }
        else {
            return this.withSeries(columnNameOrNames, this.getSeries(columnNameOrNames).parseInts());
        }
        var e_41, _a;
    };
    /**
     * Parse a column with string values to a column with float values.
     *
     * @param columnNameOrNames - Specifies the column name or array of column names to parse.
     *
     * @returns  Returns a new dataframe with a particular named column parsed as floats.
     */
    DataFrame.prototype.parseFloats = function (columnNameOrNames) {
        if (Sugar.Object.isArray(columnNameOrNames)) {
            var working = this;
            try {
                for (var columnNameOrNames_2 = __values(columnNameOrNames), columnNameOrNames_2_1 = columnNameOrNames_2.next(); !columnNameOrNames_2_1.done; columnNameOrNames_2_1 = columnNameOrNames_2.next()) {
                    var columnName = columnNameOrNames_2_1.value;
                    working = working.parseFloats(columnName);
                }
            }
            catch (e_42_1) { e_42 = { error: e_42_1 }; }
            finally {
                try {
                    if (columnNameOrNames_2_1 && !columnNameOrNames_2_1.done && (_a = columnNameOrNames_2.return)) _a.call(columnNameOrNames_2);
                }
                finally { if (e_42) throw e_42.error; }
            }
            return working;
        }
        else {
            return this.withSeries(columnNameOrNames, this.getSeries(columnNameOrNames).parseFloats());
        }
        var e_42, _a;
    };
    /**
     * Parse a column with string values to a column with date values.
     *
     * @param columnNameOrNames - Specifies the column name or array of column names to parse.
     * @param [formatString] - Optional formatting string for dates.
     *
     * @returns Returns a new dataframe with a particular named column parsed as dates.
     */
    DataFrame.prototype.parseDates = function (columnNameOrNames, formatString) {
        if (formatString) {
            chai_1.assert.isString(formatString, "Expected optional 'formatString' parameter to 'DataFrame.parseDates' to be a string (if specified).");
        }
        if (Sugar.Object.isArray(columnNameOrNames)) {
            var working = this;
            try {
                for (var columnNameOrNames_3 = __values(columnNameOrNames), columnNameOrNames_3_1 = columnNameOrNames_3.next(); !columnNameOrNames_3_1.done; columnNameOrNames_3_1 = columnNameOrNames_3.next()) {
                    var columnName = columnNameOrNames_3_1.value;
                    working = working.parseDates(columnName, formatString);
                }
            }
            catch (e_43_1) { e_43 = { error: e_43_1 }; }
            finally {
                try {
                    if (columnNameOrNames_3_1 && !columnNameOrNames_3_1.done && (_a = columnNameOrNames_3.return)) _a.call(columnNameOrNames_3);
                }
                finally { if (e_43) throw e_43.error; }
            }
            return working;
        }
        else {
            return this.withSeries(columnNameOrNames, this.getSeries(columnNameOrNames).parseDates(formatString));
        }
        var e_43, _a;
    };
    /**
     * Convert a column of values of different types to a column of string values.
     *
     * @param columnNames - Specifies the column name or array of column names to convert to strings. Can also be a format spec that specifies which columns to convert and what their format should be.
     * @param [formatString] - Optional formatting string for dates.
     *
     * Numeral.js is used for number formatting.
     * http://numeraljs.com/
     *
     * Moment is used for date formatting.
     * https://momentjs.com/docs/#/parsing/string-format/
     *
     * @returns Returns a new dataframe with a particular named column convert to strings.
     */
    DataFrame.prototype.toStrings = function (columnNames, formatString) {
        if (Sugar.Object.isObject(columnNames)) {
            try {
                for (var _a = __values(Object.keys(columnNames)), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var columnName = _b.value;
                    chai_1.assert.isString(columnNames[columnName], "Expected values of 'columnNames' parameter to be strings when a format spec is passed in.");
                }
            }
            catch (e_44_1) { e_44 = { error: e_44_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_44) throw e_44.error; }
            }
            chai_1.assert.isUndefined(formatString, "Optional 'formatString' parameter to 'DataFrame.toStrings' should not be set when passing in a format spec.");
        }
        else {
            if (!Sugar.Object.isArray(columnNames)) {
                chai_1.assert.isString(columnNames, "Expected 'columnNames' parameter to 'DataFrame.toStrings' to be a string, array of strings or format spec that specifes which columns should be converted to strings.");
            }
            if (formatString) {
                chai_1.assert.isString(formatString, "Expected optional 'formatString' parameter to 'DataFrame.toStrings' to be a string (if specified).");
            }
        }
        if (Sugar.Object.isObject(columnNames)) {
            var working = this;
            try {
                for (var _d = __values(Object.keys(columnNames)), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var columnName = _e.value;
                    working = working.toStrings(columnName, formatString);
                }
            }
            catch (e_45_1) { e_45 = { error: e_45_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_f = _d.return)) _f.call(_d);
                }
                finally { if (e_45) throw e_45.error; }
            }
            return working;
        }
        else if (Sugar.Object.isArray(columnNames)) {
            var working = this;
            try {
                for (var columnNames_9 = __values(columnNames), columnNames_9_1 = columnNames_9.next(); !columnNames_9_1.done; columnNames_9_1 = columnNames_9.next()) {
                    var columnName = columnNames_9_1.value;
                    var columnFormatString = columnNames[columnName];
                    working = working.toStrings(columnName, columnFormatString);
                }
            }
            catch (e_46_1) { e_46 = { error: e_46_1 }; }
            finally {
                try {
                    if (columnNames_9_1 && !columnNames_9_1.done && (_g = columnNames_9.return)) _g.call(columnNames_9);
                }
                finally { if (e_46) throw e_46.error; }
            }
            return working;
        }
        else {
            var singleColumnName = columnNames;
            return this.withSeries(singleColumnName, this.getSeries(singleColumnName).toStrings(formatString));
        }
        var e_44, _c, e_45, _f, e_46, _g;
    };
    /**
     * Produces a new data frame with all string values truncated to the requested maximum length.
     *
     * @param maxLength - The maximum length of the string values after truncation.
     *
     * @returns Returns a new dataframe with all strings truncated to the specified maximum length.
     */
    DataFrame.prototype.truncateStrings = function (maxLength) {
        chai_1.assert.isNumber(maxLength, "Expected 'maxLength' parameter to 'truncateStrings' to be an integer.");
        return this.select(function (row) {
            var output = {};
            try {
                for (var _a = __values(Object.keys(row)), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var key = _b.value;
                    var value = row[key];
                    if (Sugar.Object.isString(value)) {
                        output[key] = value.substring(0, maxLength);
                    }
                    else {
                        output[key] = value;
                    }
                }
            }
            catch (e_47_1) { e_47 = { error: e_47_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_47) throw e_47.error; }
            }
            return output;
            var e_47, _c;
        });
    };
    /**
     * Forces lazy evaluation to complete and 'bakes' the dataframe into memory.
     *
     * @returns Returns a dataframe that has been 'baked', all lazy evaluation has completed.
     */
    DataFrame.prototype.bake = function () {
        if (this.getContent().isBaked) {
            // Already baked.
            return this;
        }
        return new DataFrame({
            columnNames: this.getColumnNames(),
            values: this.toArray(),
            pairs: this.toPairs(),
            baked: true,
        });
    };
    /**
     * Reverse the dataframe.
     *
     * @returns Returns a new dataframe that is the reverse of the input.
     */
    DataFrame.prototype.reverse = function () {
        var _this = this;
        return new DataFrame(function () {
            var content = _this.getContent();
            return {
                columnNames: content.columnNames,
                values: new reverse_iterable_1.ReverseIterable(content.values),
                index: new reverse_iterable_1.ReverseIterable(content.index),
                pairs: new reverse_iterable_1.ReverseIterable(content.pairs)
            };
        });
    };
    /**
     * Returns only values in the dataframe that are distinct.
     *
     * @param selector - Selects the value used to compare for duplicates.
     *
     * @returns Returns a dataframe containing only unique values as determined by the 'selector' function.
     */
    DataFrame.prototype.distinct = function (selector) {
        var _this = this;
        return new DataFrame(function () {
            var content = _this.getContent();
            return {
                columnNames: content.columnNames,
                values: new distinct_iterable_1.DistinctIterable(content.values, selector),
                pairs: new distinct_iterable_1.DistinctIterable(content.pairs, function (pair) { return selector && selector(pair[1]) || pair[1]; })
            };
        });
    };
    /**
     * Groups the dataframe according to the selector.
     *
     * @param selector - Selector that defines the value to group by.
     *
     * @returns Returns a series of groups. Each group is a series with values that have been grouped by the 'selector' function.
     */
    DataFrame.prototype.groupBy = function (selector) {
        var _this = this;
        chai_1.assert.isFunction(selector, "Expected 'selector' parameter to 'DataFrame.groupBy' to be a selector function that determines the value to group the series by.");
        return new series_1.Series(function () {
            var groups = []; // Each group, in order of discovery.
            var groupMap = {}; // Group map, records groups by key.
            var valueIndex = 0;
            try {
                for (var _a = __values(_this.getContent().pairs), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var pair = _b.value;
                    var groupKey = selector(pair[1], valueIndex);
                    ++valueIndex;
                    var existingGroup = groupMap[groupKey];
                    if (existingGroup) {
                        existingGroup.push(pair);
                    }
                    else {
                        var newGroup = [];
                        newGroup.push(pair);
                        groups.push(newGroup);
                        groupMap[groupKey] = newGroup;
                    }
                }
            }
            catch (e_48_1) { e_48 = { error: e_48_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_48) throw e_48.error; }
            }
            return {
                values: groups.map(function (group) { return new DataFrame({ pairs: group }); })
            };
            var e_48, _c;
        });
    };
    /**
     * Group sequential values into a series of windows.
     *
     * @param selector - Optional selector that defines the value to group by.
     *
     * @returns Returns a series of groups. Each group is a dataframe with values that have been grouped by the 'selector' function.
     */
    DataFrame.prototype.groupSequentialBy = function (selector) {
        if (selector) {
            chai_1.assert.isFunction(selector, "Expected 'selector' parameter to 'DataFrame.groupSequentialBy' to be a selector function that determines the value to group the series by.");
        }
        else {
            selector = function (value) { return value; };
        }
        return this.variableWindow(function (a, b) { return selector(a) === selector(b); });
    };
    /**
     * Concatenate multiple dataframes into a single dataframe.
     *
     * @param dataframes - Array of dataframes to concatenate.
     *
     * @returns Returns a single dataframe concatenated from multiple input dataframes.
     */
    DataFrame.concat = function (dataframes) {
        chai_1.assert.isArray(dataframes, "Expected 'dataframes' parameter to 'DataFrame.concat' to be an array of dataframes.");
        return new DataFrame(function () {
            var upcast = dataframes; // Upcast so that we can access private index, values and pairs.
            var contents = upcast.map(function (dataframe) { return dataframe.getContent(); });
            var columnNames = [];
            try {
                for (var contents_1 = __values(contents), contents_1_1 = contents_1.next(); !contents_1_1.done; contents_1_1 = contents_1.next()) {
                    var content = contents_1_1.value;
                    try {
                        for (var _a = __values(content.columnNames), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var columnName = _b.value;
                            columnNames.push(columnName);
                        }
                    }
                    catch (e_49_1) { e_49 = { error: e_49_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_49) throw e_49.error; }
                    }
                }
            }
            catch (e_50_1) { e_50 = { error: e_50_1 }; }
            finally {
                try {
                    if (contents_1_1 && !contents_1_1.done && (_d = contents_1.return)) _d.call(contents_1);
                }
                finally { if (e_50) throw e_50.error; }
            }
            columnNames = utils_1.makeDistinct(columnNames);
            return {
                columnNames: columnNames,
                values: new concat_iterable_1.ConcatIterable(contents.map(function (content) { return content.values; })),
                pairs: new concat_iterable_1.ConcatIterable(contents.map(function (content) { return content.pairs; })),
            };
            var e_50, _d, e_49, _c;
        });
    };
    /**
     * Concatenate multiple other dataframes onto this dataframe.
     *
     * @param dataframes - Multiple arguments. Each can be either a dataframe or an array of dataframes.
     *
     * @returns Returns a single dataframes concatenated from multiple input dataframes.
     */
    DataFrame.prototype.concat = function () {
        var dataframes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            dataframes[_i] = arguments[_i];
        }
        var concatInput = [this];
        try {
            for (var dataframes_1 = __values(dataframes), dataframes_1_1 = dataframes_1.next(); !dataframes_1_1.done; dataframes_1_1 = dataframes_1.next()) {
                var input = dataframes_1_1.value;
                if (Sugar.Object.isArray(input)) {
                    try {
                        for (var input_1 = __values(input), input_1_1 = input_1.next(); !input_1_1.done; input_1_1 = input_1.next()) {
                            var subInput = input_1_1.value;
                            concatInput.push(subInput);
                        }
                    }
                    catch (e_51_1) { e_51 = { error: e_51_1 }; }
                    finally {
                        try {
                            if (input_1_1 && !input_1_1.done && (_a = input_1.return)) _a.call(input_1);
                        }
                        finally { if (e_51) throw e_51.error; }
                    }
                }
                else {
                    concatInput.push(input);
                }
            }
        }
        catch (e_52_1) { e_52 = { error: e_52_1 }; }
        finally {
            try {
                if (dataframes_1_1 && !dataframes_1_1.done && (_b = dataframes_1.return)) _b.call(dataframes_1);
            }
            finally { if (e_52) throw e_52.error; }
        }
        return DataFrame.concat(concatInput);
        var e_52, _b, e_51, _a;
    };
    /**
    * Zip together multiple dataframes to create a new dataframe.
    * Preserves the index of the first dataframe.
    *
    * @param dataframes - Multiple arguments. Each can be either a dataframe or an array of dataframes.
    * @param zipper - Selector function that produces a new dataframe based on the input dataframes.
    *
    * @returns Returns a single dataframe zipped from multiple input dataframes.
    */
    DataFrame.zip = function (dataframes, zipper) {
        chai_1.assert.isArray(dataframes, "Expected 'dataframe' parameter to 'DataFrame.zip' to be an array of dataframes.");
        if (dataframes.length === 0) {
            return new DataFrame();
        }
        var firstSeries = dataframes[0];
        if (firstSeries.none()) {
            return new DataFrame();
        }
        return new DataFrame(function () {
            var firstSeriesUpCast = firstSeries;
            var upcast = dataframes; // Upcast so that we can access private index, values and pairs.
            return {
                index: firstSeriesUpCast.getContent().index,
                values: new zip_iterable_1.ZipIterable(upcast.map(function (s) { return s.getContent().values; }), zipper),
            };
        });
    };
    DataFrame.prototype.zip = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var selector = args[args.length - 1];
        var input = [this].concat(args.slice(0, args.length - 1));
        return DataFrame.zip(input, function (values) { return selector.apply(void 0, __spread(values)); });
    };
    /**
     * Sorts the dataframe by a value defined by the selector (ascending).
     *
     * @param selector Selects the value to sort by.
     *
     * @returns Returns a new ordered dataframe that has been sorted by the value returned by the selector.
     */
    DataFrame.prototype.orderBy = function (selector) {
        //TODO: Should pass a config fn to OrderedSeries.
        return new OrderedDataFrame(this.getContent().values, this.getContent().pairs, selector, ordered_iterable_1.Direction.Ascending, null);
    };
    /**
     * Sorts the dataframe by a value defined by the selector (descending).
     *
     * @param selector Selects the value to sort by.
     *
     * @returns Returns a new ordered dataframe that has been sorted by the value returned by the selector.
     */
    DataFrame.prototype.orderByDescending = function (selector) {
        //TODO: Should pass a config fn to OrderedSeries.
        return new OrderedDataFrame(this.getContent().values, this.getContent().pairs, selector, ordered_iterable_1.Direction.Descending, null);
    };
    /**
     * Returns the unique union of values between two dataframes.
     *
     * @param other - The other dataframes to combine.
     * @param [selector] - Optional function that selects the value to compare to detemrine distinctness.
     *
     * @returns Returns the union of two dataframes.
     */
    DataFrame.prototype.union = function (other, selector) {
        if (selector) {
            chai_1.assert.isFunction(selector, "Expected optional 'selector' parameter to 'DataFrame.union' to be a selector function.");
        }
        return this.concat(other).distinct(selector);
    };
    ;
    /**
     * Returns the intersection of values between two dataframes.
     *
     * @param inner - The other dataframe to combine.
     * @param [outerSelector] - Optional function to select the key for matching the two dataframes.
     * @param [innerSelector] - Optional function to select the key for matching the two dataframes.
     *
     * @returns Returns the intersection of two series.
     */
    DataFrame.prototype.intersection = function (inner, outerSelector, innerSelector) {
        if (outerSelector) {
            chai_1.assert.isFunction(outerSelector, "Expected optional 'outerSelector' parameter to 'DataFrame.intersection' to be a function.");
        }
        else {
            outerSelector = function (value) { return value; };
        }
        if (innerSelector) {
            chai_1.assert.isFunction(innerSelector, "Expected optional 'innerSelector' parameter to 'DataFrame.intersection' to be a function.");
        }
        else {
            innerSelector = function (value) { return value; };
        }
        var outer = this;
        return outer.where(function (outerValue) {
            var outerKey = outerSelector(outerValue);
            return inner
                .where(function (innerValue) { return outerKey === innerSelector(innerValue); })
                .any();
        });
    };
    ;
    /**
     * Returns the exception of values between two dataframes.
     *
     * @param inner - The other dataframe to combine.
     * @param [outerSelector] - Optional function to select the key for matching the two dataframes.
     * @param [innerSelector] - Optional function to select the key for matching the two dataframes.
     *
     * @returns Returns the difference between the two series.
     */
    DataFrame.prototype.except = function (inner, outerSelector, innerSelector) {
        if (outerSelector) {
            chai_1.assert.isFunction(outerSelector, "Expected optional 'outerSelector' parameter to 'DataFrame.except' to be a function.");
        }
        else {
            outerSelector = function (value) { return value; };
        }
        if (innerSelector) {
            chai_1.assert.isFunction(innerSelector, "Expected optional 'innerSelector' parameter to 'DataFrame.except' to be a function.");
        }
        else {
            innerSelector = function (value) { return value; };
        }
        var outer = this;
        return outer.where(function (outerValue) {
            var outerKey = outerSelector(outerValue);
            return inner
                .where(function (innerValue) { return outerKey === innerSelector(innerValue); })
                .none();
        });
    };
    ;
    /**
      * Correlates the elements of two dataframes on matching keys.
      *
      * @param this - The outer dataframe to join.
      * @param inner - The inner dataframe to join.
      * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
      * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
      * @param resultSelector - Selector that defines how to merge outer and inner values.
      *
      * @returns Returns the joined dataframe.
      */
    DataFrame.prototype.join = function (inner, outerKeySelector, innerKeySelector, resultSelector) {
        chai_1.assert.isFunction(outerKeySelector, "Expected 'outerKeySelector' parameter of 'DataFrame.join' to be a selector function.");
        chai_1.assert.isFunction(innerKeySelector, "Expected 'innerKeySelector' parameter of 'DataFrame.join' to be a selector function.");
        chai_1.assert.isFunction(resultSelector, "Expected 'resultSelector' parameter of 'DataFrame.join' to be a selector function.");
        var outer = this;
        return new DataFrame(function () {
            var innerMap = inner
                .groupBy(innerKeySelector)
                .toObject(function (group) { return innerKeySelector(group.first()); }, function (group) { return group; });
            var outerContent = outer.getContent();
            var output = [];
            try {
                for (var outer_1 = __values(outer), outer_1_1 = outer_1.next(); !outer_1_1.done; outer_1_1 = outer_1.next()) {
                    var outerValue = outer_1_1.value;
                    var outerKey = outerKeySelector(outerValue);
                    var innerGroup = innerMap[outerKey];
                    if (innerGroup) {
                        try {
                            for (var innerGroup_1 = __values(innerGroup), innerGroup_1_1 = innerGroup_1.next(); !innerGroup_1_1.done; innerGroup_1_1 = innerGroup_1.next()) {
                                var innerValue = innerGroup_1_1.value;
                                output.push(resultSelector(outerValue, innerValue));
                            }
                        }
                        catch (e_53_1) { e_53 = { error: e_53_1 }; }
                        finally {
                            try {
                                if (innerGroup_1_1 && !innerGroup_1_1.done && (_a = innerGroup_1.return)) _a.call(innerGroup_1);
                            }
                            finally { if (e_53) throw e_53.error; }
                        }
                    }
                }
            }
            catch (e_54_1) { e_54 = { error: e_54_1 }; }
            finally {
                try {
                    if (outer_1_1 && !outer_1_1.done && (_b = outer_1.return)) _b.call(outer_1);
                }
                finally { if (e_54) throw e_54.error; }
            }
            return {
                values: output
            };
            var e_54, _b, e_53, _a;
        });
    };
    /**
     * Performs an outer join on two series. Correlates the elements based on matching keys.
     * Includes elements from both series that have no correlation in the other series.
     *
     * @param this - The outer series to join.
     * @param inner - The inner series to join.
     * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
     * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
     * @param resultSelector - Selector that defines how to merge outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @returns Returns the joined series.
     */
    DataFrame.prototype.joinOuter = function (inner, outerKeySelector, innerKeySelector, resultSelector) {
        chai_1.assert.isFunction(outerKeySelector, "Expected 'outerKeySelector' parameter of 'DataFrame.joinOuter' to be a selector function.");
        chai_1.assert.isFunction(innerKeySelector, "Expected 'innerKeySelector' parameter of 'DataFrame.joinOuter' to be a selector function.");
        chai_1.assert.isFunction(resultSelector, "Expected 'resultSelector' parameter of 'DataFrame.joinOuter' to be a selector function.");
        // Get the results in the outer that are not in the inner.
        var outer = this;
        var outerResult = outer.except(inner, outerKeySelector, innerKeySelector)
            .select(function (outer) { return resultSelector(outer, null); })
            .resetIndex();
        // Get the results in the inner that are not in the outer.
        var innerResult = inner.except(outer, innerKeySelector, outerKeySelector)
            .select(function (inner) { return resultSelector(null, inner); })
            .resetIndex();
        // Get the intersection of results between inner and outer.
        var intersectionResults = outer.join(inner, outerKeySelector, innerKeySelector, resultSelector);
        return outerResult
            .concat(intersectionResults)
            .concat(innerResult)
            .resetIndex();
    };
    ;
    /**
     * Performs a left outer join on two dataframes. Correlates the elements based on matching keys.
     * Includes left elements that have no correlation.
     *
     * @param this - The outer dataframe to join.
     * @param inner - The inner dataframe to join.
     * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
     * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
     * @param resultSelector - Selector that defines how to merge outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @returns Returns the joined dataframes.
     */
    DataFrame.prototype.joinOuterLeft = function (inner, outerKeySelector, innerKeySelector, resultSelector) {
        chai_1.assert.isFunction(outerKeySelector, "Expected 'outerKeySelector' parameter of 'DataFrame.joinOuterLeft' to be a selector function.");
        chai_1.assert.isFunction(innerKeySelector, "Expected 'innerKeySelector' parameter of 'DataFrame.joinOuterLeft' to be a selector function.");
        chai_1.assert.isFunction(resultSelector, "Expected 'resultSelector' parameter of 'DataFrame.joinOuterLeft' to be a selector function.");
        // Get the results in the outer that are not in the inner.
        var outer = this;
        var outerResult = outer.except(inner, outerKeySelector, innerKeySelector)
            .select(function (outer) { return resultSelector(outer, null); })
            .resetIndex();
        // Get the intersection of results between inner and outer.
        var intersectionResults = outer.join(inner, outerKeySelector, innerKeySelector, resultSelector);
        return outerResult
            .concat(intersectionResults)
            .resetIndex();
    };
    ;
    /**
     * Performs a right outer join on two dataframes. Correlates the elements based on matching keys.
     * Includes right elements that have no correlation.
     *
     * @param this - The outer dataframe to join.
     * @param inner - The inner dataframe to join.
     * @param outerKeySelector - Selector that chooses the join key from the outer sequence.
     * @param innerKeySelector - Selector that chooses the join key from the inner sequence.
     * @param resultSelector - Selector that defines how to merge outer and inner values.
     *
     * Implementation from here:
     *
     * 	http://blogs.geniuscode.net/RyanDHatch/?p=116
     *
     * @returns Returns the joined dataframes.
     */
    DataFrame.prototype.joinOuterRight = function (inner, outerKeySelector, innerKeySelector, resultSelector) {
        chai_1.assert.isFunction(outerKeySelector, "Expected 'outerKeySelector' parameter of 'DataFrame.joinOuterRight' to be a selector function.");
        chai_1.assert.isFunction(innerKeySelector, "Expected 'innerKeySelector' parameter of 'DataFrame.joinOuterRight' to be a selector function.");
        chai_1.assert.isFunction(resultSelector, "Expected 'resultSelector' parameter of 'DataFrame.joinOuterRight' to be a selector function.");
        // Get the results in the inner that are not in the outer.
        var outer = this;
        var innerResult = inner.except(outer, innerKeySelector, outerKeySelector)
            .select(function (inner) { return resultSelector(null, inner); })
            .resetIndex();
        // Get the intersection of results between inner and outer.
        var intersectionResults = outer.join(inner, outerKeySelector, innerKeySelector, resultSelector);
        return intersectionResults
            .concat(innerResult)
            .resetIndex();
    };
    /**
     * Reshape (or pivot) a table based on column values.
     * This effiectively a short-hand for multiple grouping operations and an aggregation.
     *
     * @param columnOrColumns - Column name whose values make the new DataFrame's columns.
     * @param valueColumnNameOrSpec - Column name or column spec that defines the columns whose values should be aggregated.
     * @param [aggregator] - Optional function used to aggregate pivotted vales.
     *
     * @returns Returns a new dataframe that has been pivoted based on a particular column's values.
     */
    DataFrame.prototype.pivot = function (columnOrColumns, valueColumnNameOrSpec, aggregator) {
        var columnNames;
        if (Sugar.Object.isString(columnOrColumns)) {
            columnNames = [columnOrColumns];
        }
        else {
            chai_1.assert.isArray(columnOrColumns, "Expected 'columnOrColumns' parameter to 'DataFrame.pivot' to be a string or an array of strings that identifies the column(s) whose values make the new DataFrame's columns.");
            columnNames = Array.from(columnOrColumns);
            chai_1.assert(columnNames.length > 0, "Expected 'columnOrColumns' parameter to 'DataFrame.pivot' to contain at least one string.");
            try {
                for (var columnNames_10 = __values(columnNames), columnNames_10_1 = columnNames_10.next(); !columnNames_10_1.done; columnNames_10_1 = columnNames_10.next()) {
                    var columnName = columnNames_10_1.value;
                    chai_1.assert.isString(columnName, "Expected 'columnOrColumns' parameter to 'DataFrame.pivot' to be an array of strings, each string identifies a column in the DataFrame on which to pivot.");
                }
            }
            catch (e_55_1) { e_55 = { error: e_55_1 }; }
            finally {
                try {
                    if (columnNames_10_1 && !columnNames_10_1.done && (_a = columnNames_10.return)) _a.call(columnNames_10);
                }
                finally { if (e_55) throw e_55.error; }
            }
        }
        var aggSpec;
        if (!Sugar.Object.isObject(valueColumnNameOrSpec)) {
            chai_1.assert.isString(valueColumnNameOrSpec, "Expected 'value' parameter to 'DataFrame.pivot' to be a string that identifies the column whose values to aggregate or a column spec that defines which column contains the value ot aggregate and the ways to aggregate that value.");
            chai_1.assert.isFunction(aggregator, "Expected 'aggregator' parameter to 'DataFrame.pivot' to be a function to aggegrate pivoted values.");
            var aggColumnName = valueColumnNameOrSpec;
            var outputSpec = {};
            outputSpec[aggColumnName] = aggregator;
            aggSpec = {};
            aggSpec[aggColumnName] = outputSpec;
        }
        else {
            aggSpec = valueColumnNameOrSpec;
        }
        var firstColumnName = columnNames[0];
        var working = this.groupBy(function (row) { return row[firstColumnName]; })
            .select(function (group) {
            var output = {};
            output[firstColumnName] = group.first()[firstColumnName];
            output.src = group;
            return output;
        });
        var _loop_2 = function (columnNameIndex) {
            var nextColumnName = columnNames[columnNameIndex];
            working = working.selectMany(function (parentGroup) {
                var src = parentGroup.src;
                return src.groupBy(function (row) { return row[nextColumnName]; })
                    .select(function (subGroup) {
                    var output = Object.assign({}, parentGroup);
                    output[nextColumnName] = subGroup.first()[nextColumnName];
                    output.src = subGroup;
                    return output;
                });
            });
        };
        for (var columnNameIndex = 1; columnNameIndex < columnNames.length; ++columnNameIndex) {
            _loop_2(columnNameIndex);
        }
        var valueColumnNames = Object.keys(aggSpec);
        var outputColumnsMap = utils_1.toMap(valueColumnNames, function (valueColumnName) { return valueColumnName; }, function (valueColumnName) { return Object.keys(aggSpec[valueColumnName]); });
        var pivotted = working.inflate(function (row) {
            var _loop_3 = function (valueColumnName) {
                var outputColumnNames = outputColumnsMap[valueColumnName];
                try {
                    for (var outputColumnNames_1 = __values(outputColumnNames), outputColumnNames_1_1 = outputColumnNames_1.next(); !outputColumnNames_1_1.done; outputColumnNames_1_1 = outputColumnNames_1.next()) {
                        var outputColumName = outputColumnNames_1_1.value;
                        var aggregatorFn = aggSpec[valueColumnName][outputColumName];
                        row[outputColumName] = aggregatorFn(row.src.deflate(function (srcRow) { return srcRow[valueColumnName]; }));
                    }
                }
                catch (e_56_1) { e_56 = { error: e_56_1 }; }
                finally {
                    try {
                        if (outputColumnNames_1_1 && !outputColumnNames_1_1.done && (_a = outputColumnNames_1.return)) _a.call(outputColumnNames_1);
                    }
                    finally { if (e_56) throw e_56.error; }
                }
                var e_56, _a;
            };
            try {
                for (var valueColumnNames_1 = __values(valueColumnNames), valueColumnNames_1_1 = valueColumnNames_1.next(); !valueColumnNames_1_1.done; valueColumnNames_1_1 = valueColumnNames_1.next()) {
                    var valueColumnName = valueColumnNames_1_1.value;
                    _loop_3(valueColumnName);
                }
            }
            catch (e_57_1) { e_57 = { error: e_57_1 }; }
            finally {
                try {
                    if (valueColumnNames_1_1 && !valueColumnNames_1_1.done && (_a = valueColumnNames_1.return)) _a.call(valueColumnNames_1);
                }
                finally { if (e_57) throw e_57.error; }
            }
            delete row.src;
            return row;
            var e_57, _a;
        });
        var ordered = pivotted.orderBy(function (row) { return row[firstColumnName]; });
        var _loop_4 = function (columnNameIndex) {
            var nextColumnName = columnNames[columnNameIndex];
            ordered = ordered.thenBy(function (row) { return row[nextColumnName]; });
        };
        for (var columnNameIndex = 1; columnNameIndex < columnNames.length; ++columnNameIndex) {
            _loop_4(columnNameIndex);
        }
        return ordered;
        var e_55, _a;
    };
    /**
     * Insert a pair at the start of the dataframe.
     *
     * @param pair - The pair to insert.
     *
     * @returns Returns a new dataframe with the specified pair inserted.
     */
    DataFrame.prototype.insertPair = function (pair) {
        chai_1.assert.isArray(pair, "Expected 'pair' parameter to 'DataFrame.insertPair' to be an array.");
        chai_1.assert(pair.length === 2, "Expected 'pair' parameter to 'DataFrame.insertPair' to be an array with two elements. The first element is the index, the second is the value.");
        return (new DataFrame({ pairs: [pair] })).concat(this);
    };
    /**
     * Append a pair to the end of a dataframe.
     *
     * @param pair - The pair to append.
     *
     * @returns Returns a new dataframe with the specified pair appended.
     */
    DataFrame.prototype.appendPair = function (pair) {
        chai_1.assert.isArray(pair, "Expected 'pair' parameter to 'DataFrame.appendPair' to be an array.");
        chai_1.assert(pair.length === 2, "Expected 'pair' parameter to 'DataFrame.appendPair' to be an array with two elements. The first element is the index, the second is the value.");
        return this.concat(new DataFrame({ pairs: [pair] }));
    };
    /**
     * Fill gaps in a dataframe.
     *
     * @param comparer - Comparer that is passed pairA and pairB, two consecutive rows, return truthy if there is a gap between the rows, or falsey if there is no gap.
     * @param generator - Generator that is passed pairA and pairB, two consecutive rows, returns an array of pairs that fills the gap between the rows.
     *
     * @returns Returns a new dataframe with gaps filled in.
     */
    DataFrame.prototype.fillGaps = function (comparer, generator) {
        chai_1.assert.isFunction(comparer, "Expected 'comparer' parameter to 'DataFrame.fillGaps' to be a comparer function that compares two values and returns a boolean.");
        chai_1.assert.isFunction(generator, "Expected 'generator' parameter to 'DataFrame.fillGaps' to be a generator function that takes two values and returns an array of generated pairs to span the gap.");
        return this.rollingWindow(2)
            .selectMany(function (window) {
            var pairs = window.toPairs();
            var pairA = pairs[0];
            var pairB = pairs[1];
            if (!comparer(pairA, pairB)) {
                return [pairA];
            }
            var generatedRows = generator(pairA, pairB);
            chai_1.assert.isArray(generatedRows, "Expected return from 'generator' parameter to 'DataFrame.fillGaps' to be an array of pairs, instead got a " + typeof (generatedRows));
            return [pairA].concat(generatedRows);
        })
            .withIndex(function (pair) { return pair[0]; })
            .inflate(function (pair) { return pair[1]; })
            .concat(this.tail(1));
    };
    /**
     * Returns the specified default sequence if the dataframe is empty.
     *
     * @param defaultSequence - Default sequence to return if the dataframe is empty.
     *
     * @returns Returns 'defaultSequence' if the dataframe is empty.
     */
    DataFrame.prototype.defaultIfEmpty = function (defaultSequence) {
        if (this.none()) {
            if (defaultSequence instanceof DataFrame) {
                return defaultSequence;
            }
            else if (Sugar.Object.isArray(defaultSequence)) {
                return new DataFrame(defaultSequence);
            }
            else {
                throw new Error("Expected 'defaultSequence' parameter to 'DataFrame.defaultIfEmpty' to be an array or a series.");
            }
        }
        else {
            return this;
        }
    };
    /**
     * Detect the the frequency of the types of the values in the dataframe.
     *
     * @returns Returns a dataframe that describes the data types contained in the dataframe.
     */
    DataFrame.prototype.detectTypes = function () {
        var _this = this;
        return new DataFrame(function () {
            var typeFrequencies = _this.getColumns()
                .selectMany(function (column) {
                return column.series.detectTypes()
                    .select(function (typeFrequency) {
                    var output = Object.assign({}, typeFrequency);
                    output.Column = column.name;
                    return output;
                });
            });
            return {
                columnNames: ["Type", "Frequency", "Column"],
                values: typeFrequencies,
            };
        });
    };
    /**
     * Detect the frequency of the values in the dataframe.
     *
     * @returns Returns a dataframe that describes the values contained in the dataframe.
     */
    DataFrame.prototype.detectValues = function () {
        var _this = this;
        return new DataFrame(function () {
            var valueFrequencies = _this.getColumns()
                .selectMany(function (column) {
                return column.series.detectValues()
                    .select(function (valueFrequency) {
                    var output = Object.assign({}, valueFrequency);
                    output.Column = column.name;
                    return output;
                });
            });
            return {
                columnNames: ["Value", "Frequency", "Column"],
                values: valueFrequencies,
            };
        });
    };
    /**
     * Serialize the dataframe to JSON.
     *
     *  @returns Returns a JSON format string representing the dataframe.
     */
    DataFrame.prototype.toJSON = function () {
        return JSON.stringify(this.toArray(), null, 4);
    };
    /**
     * Serialize the dataframe to CSV.
     *
     *  @returns Returns a CSV format string representing the dataframe.
     */
    DataFrame.prototype.toCSV = function () {
        var data = [this.getColumnNames()].concat(this.toRows());
        return PapaParse.unparse(data);
    };
    /**
     * Treat the dataframe as CSV data for purposes of serialization.
     *
     * @returns Returns an object that represents the dataframe for serialization in the CSV format. Call `writeFile`, `writeFileSync` to output the dataframe via different media.
     */
    DataFrame.prototype.asCSV = function () {
        return new CsvSerializer(this);
    };
    /**
     * Treat the dataframe as JSON data for purposes of serialization.
     *
     * @returns Returns an object that can serialize the dataframe in the JSON format. Call `writeFile` or `writeFileSync` to output the dataframe via different media.
     */
    DataFrame.prototype.asJSON = function () {
        return new JsonSerializer(this);
    };
    /**
     * Serialize the data frame to HTML.
     *
     *  @returns Returns a HTML format string representing the dataframe.
     */
    DataFrame.prototype.toHTML = function () {
        var columNames = this.getColumnNames();
        var header = columNames.map(function (columnName) { return "            <th>" + columnName + "</th>"; }).join("\n");
        var pairs = this.toPairs();
        return '<table border="1" class="dataframe">\n' +
            '    <thead>\n' +
            '        <tr style="text-align: right;">\n' +
            '            <th></th>\n' +
            header +
            '\n' +
            '       </tr>\n' +
            '    </thead>\n' +
            '    <tbody>\n' +
            pairs.map(function (pair) {
                var index = pair[0];
                var value = pair[1];
                return '        <tr>\n' +
                    '            <th>' + index + '</th>\n' +
                    columNames.map(function (columName) {
                        return '            <td>' + value[columName] + '</td>';
                    })
                        .join('\n') +
                    '\n' +
                    '        </tr>';
            })
                .join('\n') +
            '\n' +
            '    </tbody>\n' +
            '</table>';
    };
    /**
     * Serialize the dataframe to an ordinary JavaScript data structure.
     */
    DataFrame.prototype.serialize = function () {
        var values = this.toArray();
        var index = this.getIndex();
        var indices = index.head(values.length).toArray();
        var columns = this.getColumns();
        var serializedColumns = utils_1.toMap(columns, function (column) { return column.name; }, function (column) { return column.type; });
        if (values.length > 0) {
            serializedColumns.__index__ = index.getType();
        }
        var serializedValues = values.map(function (value, valueindex) {
            return Object.assign({}, value, { __index__: indices[valueindex] });
        });
        try {
            // Serialize date values.
            for (var columns_1 = __values(columns), columns_1_1 = columns_1.next(); !columns_1_1.done; columns_1_1 = columns_1.next()) {
                var column = columns_1_1.value;
                if (column.type === "date") {
                    try {
                        for (var serializedValues_1 = __values(serializedValues), serializedValues_1_1 = serializedValues_1.next(); !serializedValues_1_1.done; serializedValues_1_1 = serializedValues_1.next()) {
                            var serializedValue = serializedValues_1_1.value;
                            serializedValue[column.name] = moment(serializedValue[column.name]).toISOString(true);
                        }
                    }
                    catch (e_58_1) { e_58 = { error: e_58_1 }; }
                    finally {
                        try {
                            if (serializedValues_1_1 && !serializedValues_1_1.done && (_a = serializedValues_1.return)) _a.call(serializedValues_1);
                        }
                        finally { if (e_58) throw e_58.error; }
                    }
                }
            }
        }
        catch (e_59_1) { e_59 = { error: e_59_1 }; }
        finally {
            try {
                if (columns_1_1 && !columns_1_1.done && (_b = columns_1.return)) _b.call(columns_1);
            }
            finally { if (e_59) throw e_59.error; }
        }
        return {
            columnOrder: this.getColumnNames(),
            columns: serializedColumns,
            values: serializedValues,
        };
        var e_59, _b, e_58, _a;
    };
    /**
     * Deserialize the dataframe from an ordinary JavaScript data structure.
     */
    DataFrame.deserialize = function (input) {
        var deserializedValues = input.values && input.values.map(function (row) {
            var clone = Object.assign({}, row);
            delete clone.__index__;
            return clone;
        }) || [];
        // Deserialize dates.
        if (input.columns) {
            try {
                for (var _a = __values(Object.keys(input.columns)), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var columnName = _b.value;
                    if (input.columns[columnName] !== "date") {
                        continue; // No need to process other types, they are natively supporte dby JSON.
                    }
                    try {
                        for (var deserializedValues_1 = __values(deserializedValues), deserializedValues_1_1 = deserializedValues_1.next(); !deserializedValues_1_1.done; deserializedValues_1_1 = deserializedValues_1.next()) {
                            var deserializedValue = deserializedValues_1_1.value;
                            deserializedValue[columnName] = moment(deserializedValue[columnName], moment.ISO_8601).toDate();
                        }
                    }
                    catch (e_60_1) { e_60 = { error: e_60_1 }; }
                    finally {
                        try {
                            if (deserializedValues_1_1 && !deserializedValues_1_1.done && (_c = deserializedValues_1.return)) _c.call(deserializedValues_1);
                        }
                        finally { if (e_60) throw e_60.error; }
                    }
                }
            }
            catch (e_61_1) { e_61 = { error: e_61_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                }
                finally { if (e_61) throw e_61.error; }
            }
        }
        return new DataFrame({
            columnNames: input.columnOrder || [],
            index: input.values && input.values.map(function (row) { return row.__index__; }) || [],
            values: deserializedValues,
        });
        var e_61, _d, e_60, _c;
    };
    DataFrame.defaultCountIterable = new count_iterable_1.CountIterable();
    DataFrame.defaultEmptyIterable = new empty_iterable_1.EmptyIterable();
    return DataFrame;
}());
exports.DataFrame = DataFrame;
/**
 * @hidden
 * Packages a dataframe ready for CSV serialization.
 */
var CsvSerializer = /** @class */ (function () {
    function CsvSerializer(dataframe) {
        this.dataframe = dataframe;
    }
    /**
     * Serialize the dataframe to a CSV file in the local file system.
     * Asynchronous version.
     *
     * @param filePath - Specifies the output path for the file.
     *
     *  @returns Returns a promise that resolves when the file has been written.
     */
    CsvSerializer.prototype.writeFile = function (filePath) {
        var _this = this;
        chai_1.assert.isString(filePath, "Expected 'filePath' parameter to 'DataFrame.asCSV().writeFile' to be a string that specifies the path of the file to write to the local file system.");
        return new Promise(function (resolve, reject) {
            var fs = require('fs');
            fs.writeFile(filePath, _this.dataframe.toCSV(), function (err) {
                if (err) {
                    reject(err);
                    return;
                }
                resolve();
            });
        });
    };
    /**
     * Serialize the dataframe to a CSV file in the local file system.
     * Synchronous version.
     *
     * @param filePath - Specifies the output path for the file.
     */
    CsvSerializer.prototype.writeFileSync = function (filePath) {
        chai_1.assert.isString(filePath, "Expected 'filePath' parameter to 'DataFrame.asCSV().writeFileSync' to be a string that specifies the path of the file to write to the local file system.");
        var fs = require('fs');
        fs.writeFileSync(filePath, this.dataframe.toCSV());
    };
    return CsvSerializer;
}());
/**
 * @hidden
 * Packages a dataframe ready for JSON serialization.
 */
var JsonSerializer = /** @class */ (function () {
    function JsonSerializer(dataframe) {
        this.dataframe = dataframe;
    }
    /**
     * Serialize the dataframe to a JSON file in the local file system.
     * Asynchronous version.
     *
     * @param filePath - Specifies the output path for the file.
     *
     *  @returns Returns a promise that resolves when the file has been written.
     */
    JsonSerializer.prototype.writeFile = function (filePath) {
        var _this = this;
        chai_1.assert.isString(filePath, "Expected 'filePath' parameter to 'DataFrame.asJSON().writeFile' to be a string that specifies the path of the file to write to the local file system.");
        return new Promise(function (resolve, reject) {
            var fs = require('fs');
            fs.writeFile(filePath, _this.dataframe.toJSON(), function (err) {
                if (err) {
                    reject(err);
                    return;
                }
                resolve();
            });
        });
    };
    /**
     * Serialize the dataframe to a JSON file in the local file system.
     * Synchronous version.
     *
     * @param filePath - Specifies the output path for the file.
     */
    JsonSerializer.prototype.writeFileSync = function (filePath) {
        chai_1.assert.isString(filePath, "Expected 'filePath' parameter to 'DataFrame.asJSON().writeFile' to be a string that specifies the path of the file to write to the local file system.");
        var fs = require('fs');
        fs.writeFileSync(filePath, this.dataframe.toJSON());
    };
    return JsonSerializer;
}());
/**
 * @hidden
 * A dataframe that has been ordered.
 */
var OrderedDataFrame = /** @class */ (function (_super) {
    __extends(OrderedDataFrame, _super);
    function OrderedDataFrame(values, pairs, selector, direction, parent) {
        var _this = this;
        var valueSortSpecs = [];
        var pairSortSpecs = [];
        var sortLevel = 0;
        while (parent !== null) {
            valueSortSpecs.push(OrderedDataFrame.makeSortSpec(sortLevel, parent.selector, parent.direction));
            pairSortSpecs.push(OrderedDataFrame.makeSortSpec(sortLevel, OrderedDataFrame.makePairsSelector(parent.selector), parent.direction));
            ++sortLevel;
            parent = parent.parent;
        }
        valueSortSpecs.push(OrderedDataFrame.makeSortSpec(sortLevel, selector, direction));
        pairSortSpecs.push(OrderedDataFrame.makeSortSpec(sortLevel, OrderedDataFrame.makePairsSelector(selector), direction));
        _this = _super.call(this, {
            values: new ordered_iterable_1.OrderedIterable(values, valueSortSpecs),
            pairs: new ordered_iterable_1.OrderedIterable(pairs, pairSortSpecs)
        }) || this;
        _this.parent = parent;
        _this.selector = selector;
        _this.direction = direction;
        _this.origValues = values;
        _this.origPairs = pairs;
        return _this;
    }
    //
    // Helper function to create a sort spec.
    //
    OrderedDataFrame.makeSortSpec = function (sortLevel, selector, direction) {
        return { sortLevel: sortLevel, selector: selector, direction: direction };
    };
    //
    // Helper function to make a sort selector for pairs, this captures the parent correct when generating the closure.
    //
    OrderedDataFrame.makePairsSelector = function (selector) {
        return function (pair, index) { return selector(pair[1], index); };
    };
    /**
     * Performs additional sorting (ascending).
     *
     * @param selector Selects the value to sort by.
     *
     * @returns Returns a new dataframe has been additionally sorted by the value returned by the selector.
     */
    OrderedDataFrame.prototype.thenBy = function (selector) {
        //TODO: Should pass a config fn to OrderedSeries.
        return new OrderedDataFrame(this.origValues, this.origPairs, selector, ordered_iterable_1.Direction.Ascending, this);
    };
    /**
     * Performs additional sorting (descending).
     *
     * @param selector Selects the value to sort by.
     *
     * @returns Returns a new dataframe has been additionally sorted by the value returned by the selector.
     */
    OrderedDataFrame.prototype.thenByDescending = function (selector) {
        //TODO: Should pass a config fn to OrderedSeries.
        return new OrderedDataFrame(this.origValues, this.origPairs, selector, ordered_iterable_1.Direction.Descending, this);
    };
    return OrderedDataFrame;
}(DataFrame));
//# sourceMappingURL=dataframe.js.map